<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ICGS 3D Solution Space Visualizer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            overflow: hidden;
        }

        .container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        .header {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 10px;
            max-width: 300px;
        }

        .header h1 {
            font-size: 1.5em;
            margin-bottom: 10px;
            color: #3498db;
        }

        .header p {
            font-size: 0.9em;
            opacity: 0.8;
            margin-bottom: 5px;
        }

        .controls {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 10px;
            min-width: 250px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
            color: #bdc3c7;
        }

        .control-group input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }

        .control-group select, .control-group button {
            width: 100%;
            padding: 8px;
            border: none;
            border-radius: 5px;
            background: #34495e;
            color: white;
            cursor: pointer;
        }

        .control-group button:hover {
            background: #2c3e50;
        }

        .legend {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 10px;
            max-width: 400px;
        }

        .legend h3 {
            margin-bottom: 10px;
            color: #e74c3c;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        .legend-color {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            margin-right: 10px;
        }

        .legend-line {
            width: 30px;
            margin-right: 10px;
        }

        .legend-line.dashed {
            background-image: linear-gradient(to right, transparent 50%, currentColor 50%);
            background-size: 8px 100%;
        }

        .legend h4 {
            margin: 15px 0 8px 0;
            color: #3498db;
            font-size: 0.9em;
        }

        .stats {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 10px;
            min-width: 200px;
            font-size: 0.9em;
        }

        .stats h3 {
            margin-bottom: 10px;
            color: #f39c12;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }

        #canvas-container {
            width: 100%;
            height: 100%;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 50;
            text-align: center;
        }

        .loading h2 {
            color: #3498db;
            margin-bottom: 20px;
        }

        .spinner {
            border: 3px solid #34495e;
            border-top: 3px solid #3498db;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .tooltip {
            position: absolute;
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 0.8em;
            pointer-events: none;
            z-index: 200;
            max-width: 300px;
            display: none;
        }

        .axis-label {
            position: absolute;
            font-size: 0.9em;
            color: #bdc3c7;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- En-t√™te -->
        <div class="header">
            <h1>üåå ICGS 3D Space</h1>
            <p><strong>Espace des Solutions Simplex</strong></p>
            <p>Partition par Types de Contraintes</p>
            <p>Premi√®re Mondiale - Visualisation Math√©matique</p>
        </div>

        <!-- Contr√¥les -->
        <div class="controls">
            <div class="control-group">
                <label for="rotationSpeed">Vitesse Rotation</label>
                <input type="range" id="rotationSpeed" min="0" max="2" step="0.1" value="0.5">
            </div>

            <div class="control-group">
                <label for="pointSize">Taille Points</label>
                <input type="range" id="pointSize" min="1" max="10" step="0.5" value="3">
            </div>

            <div class="control-group">
                <label for="viewMode">Mode Visualisation</label>
                <select id="viewMode">
                    <option value="points">Points Seuls</option>
                    <option value="connections">Points + Connexions</option>
                    <option value="surface">Surface Faisable</option>
                </select>
            </div>

            <div class="control-group">
                <button id="resetCamera">üì∑ Reset Cam√©ra</button>
            </div>

            <div class="control-group">
                <button id="generateMesh">üî≥ G√©n√©rer Maillage</button>
            </div>

            <div class="control-group">
                <button id="analyzeNew">üîÑ Nouvelle Analyse</button>
            </div>

            <!-- Contr√¥les √âvolution Temporelle -->
            <div class="control-group">
                <label for="timeline">üìΩÔ∏è √âvolution Temporelle</label>
                <input type="range" id="timeline" min="0" max="0" value="0" step="1">
                <span id="stepInfo">Step 0/0</span>
            </div>

            <div class="control-group">
                <button id="playPause">‚ñ∂Ô∏è Play Animation</button>
            </div>

            <div class="control-group">
                <label for="animSpeed">‚è±Ô∏è Vitesse Animation</label>
                <input type="range" id="animSpeed" min="100" max="2000" value="500" step="100">
                <span id="speedInfo">500ms</span>
            </div>

            <div class="control-group">
                <button id="toggleConstraints">üìê Afficher Plans Contraintes</button>
            </div>
        </div>

        <!-- L√©gende -->
        <div class="legend">
            <h3>üé® L√©gende - Parcours Simplex</h3>

            <h4>Points (Pivots)</h4>
            <div class="legend-item">
                <div class="legend-color" style="background: #00ff00;"></div>
                <span>Point Optimal</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #ffaa00;"></div>
                <span>Point Parcouru</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #ff6b6b;"></div>
                <span>Point Consid√©r√©</span>
            </div>

            <h4>Ar√™tes (Transitions)</h4>
            <div class="legend-item">
                <div class="legend-line" style="height: 2px; background: #00ff88;"></div>
                <span>Ar√™te Parcourue</span>
            </div>
            <div class="legend-item">
                <div class="legend-line dashed" style="height: 2px; background: #aaaaaa;"></div>
                <span>Ar√™te Consid√©r√©e</span>
            </div>
            <div class="legend-item">
                <div class="legend-line dashed" style="height: 1px; background: #666666;"></div>
                <span>Ar√™te Rejet√©e</span>
            </div>
        </div>

        <!-- Statistiques -->
        <div class="stats">
            <h3>üìä Statistiques</h3>
            <div class="stat-item">
                <span>Points Totaux:</span>
                <span id="totalPoints">-</span>
            </div>
            <div class="stat-item">
                <span>Faisables:</span>
                <span id="feasiblePoints">-</span>
            </div>
            <div class="stat-item">
                <span>Optimaux:</span>
                <span id="optimalPoints">-</span>
            </div>
            <div class="stat-item">
                <span>Taux Succ√®s:</span>
                <span id="successRate">-</span>
            </div>
        </div>

        <!-- Loading -->
        <div class="loading" id="loading">
            <h2>üöÄ Chargement Espace 3D ICGS</h2>
            <div class="spinner"></div>
            <p style="margin-top: 15px;">Analyse des solutions Simplex...</p>
        </div>

        <!-- Container Three.js -->
        <div id="canvas-container"></div>

        <!-- Tooltip -->
        <div class="tooltip" id="tooltip"></div>

        <!-- Labels axes -->
        <div class="axis-label" id="axisX" style="left: 50px; top: 50%;">Axe X: Contraintes SOURCE</div>
        <div class="axis-label" id="axisY" style="left: 50%; top: 50px;">Axe Y: Contraintes TARGET</div>
        <div class="axis-label" id="axisZ" style="right: 50px; top: 50%;">Axe Z: Contraintes SECONDARY</div>
    </div>

    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>

    <script>
        // Variables globales
        let scene, camera, renderer, controls;
        let solutionPoints = [];
        let simplexEdges = [];
        let meshPoints = [];
        let animationId;
        let tooltip;
        let solutionData = null;

        // Variables √©volution temporelle
        let animationSteps = [];
        let currentAnimationStep = 0;
        let isAnimationPlaying = false;
        let animationInterval = null;
        let animationSpeed = 500; // ms entre √©tapes
        let showConstraintPlanes = true; // Affichage plans contraintes

        // Configuration
        const config = {
            rotationSpeed: 0.005,
            pointSize: 3,
            viewMode: 'points',
            cameraDistance: 2000
        };

        // Couleurs
        const colors = {
            // Points pivots
            optimal: 0x00ff00,            // Vert - Point optimal
            traversed: 0xffaa00,          // Orange - Point parcouru
            considered: 0xff6b6b,         // Rouge clair - Point consid√©r√©
            infeasible: 0xff0000,         // Rouge - Infaisable
            meshPoint: 0xffffff,          // Blanc - Point maillage

            // Ar√™tes simplex
            edgeTraversed: 0x00ff88,      // Vert-cyan - Ar√™te parcourue
            edgeConsidered: 0xaaaaaa,     // Gris - Ar√™te consid√©r√©e
            edgeRejected: 0x666666,       // Gris fonc√© - Ar√™te rejet√©e

            axis: 0x666666                // Gris axes
        };

        // Initialisation
        document.addEventListener('DOMContentLoaded', async function() {
            tooltip = document.getElementById('tooltip');

            // V√©rifier que Three.js est charg√©
            if (typeof THREE === 'undefined') {
                console.error('THREE.js non charg√©');
                showError('THREE.js CDN non accessible');
                return;
            }

            // Attendre le chargement complet de OrbitControls
            let retries = 0;
            while (typeof THREE.OrbitControls === 'undefined' && retries < 10) {
                await new Promise(resolve => setTimeout(resolve, 100));
                retries++;
            }

            if (typeof THREE.OrbitControls === 'undefined') {
                console.warn('OrbitControls non disponible, contr√¥les limit√©s');
            }

            try {
                // üîç DEBUG: Instructions pour l'utilisateur
                console.log('üîç DEBUG MODE ACTIV√â');
                console.log('üí° Pour voir toutes les informations de debug:');
                console.log('  1. Ouvrez les outils d√©veloppeur (F12)');
                console.log('  2. Allez dans l\'onglet Console');
                console.log('  3. Recherchez les messages üîç DEBUG');
                console.log('=====================================');

                // ORDRE CRITIQUE: initThreeJS AVANT loadSolutionData
                // car loadSolutionData() appelle initializeAnimation() qui utilise scene.add()
                initThreeJS();
                createAxes();

                await loadSolutionData();
                createSolutionPoints();
                createSimplexEdges();
                setupControls();
                animate();
                hideLoading();
            } catch (error) {
                console.error('Erreur initialisation:', error);
                showError(error);
            }
        });

        // Chargement donn√©es 3D
        async function loadSolutionData() {
            try {
                // Charger donn√©es polytope authentiques depuis API
                const response = await fetch('/api/animation/polytope_data');
                if (response.ok) {
                    const result = await response.json();
                    if (result.success && result.polytope_data) {
                        solutionData = result.polytope_data;
                        solutionData.data_source = result.data_source;
                        console.log(`‚úÖ Donn√©es polytope charg√©es (${result.data_source}):`, solutionData.metadata);
                    } else {
                        throw new Error('API polytope data invalid');
                    }
                } else {
                    // Fallback vers donn√©es d√©mo si API √©choue
                    solutionData = generateDemoData();
                    console.warn('Fallback vers donn√©es d√©mo (API indisponible)');
                }

                updateStats();
                initializeAnimation();
            } catch (error) {
                console.warn('Fallback vers donn√©es d√©mo:', error);
                solutionData = generateDemoData();
                updateStats();
                initializeAnimation();
            }
        }

        // Donn√©es de d√©monstration
        function generateDemoData() {
            return {
                metadata: {
                    total_points: 5,
                    feasible_points: 5,
                    optimal_points: 5,
                    analysis_timestamp: new Date().toISOString()
                },
                solution_points: [
                    {
                        coordinates: [825, 780, 150],
                        transaction_id: "TX_demo_001",
                        feasible: true,
                        optimal: true,
                        metadata: {
                            source: "ALICE_FARM",
                            target: "BOB_FACTORY",
                            amount: 500,
                            source_sector: "AGRICULTURE",
                            target_sector: "INDUSTRY"
                        }
                    },
                    {
                        coordinates: [432, 300, 30],
                        transaction_id: "TX_demo_002",
                        feasible: true,
                        optimal: true,
                        metadata: {
                            source: "BOB_FACTORY",
                            target: "CAROL_LOGISTICS",
                            amount: 300,
                            source_sector: "INDUSTRY",
                            target_sector: "SERVICES"
                        }
                    },
                    {
                        coordinates: [208, 270, 20],
                        transaction_id: "TX_demo_003",
                        feasible: true,
                        optimal: false,
                        metadata: {
                            source: "DAVID_BANK",
                            target: "ALICE_FARM",
                            amount: 200,
                            source_sector: "FINANCE",
                            target_sector: "AGRICULTURE"
                        }
                    },
                    {
                        coordinates: [100, 50, -10],
                        transaction_id: "TX_demo_004",
                        feasible: false,
                        optimal: false,
                        metadata: {
                            source: "TEST_SOURCE",
                            target: "TEST_TARGET",
                            amount: 1000,
                            source_sector: "UNKNOWN",
                            target_sector: "UNKNOWN"
                        }
                    }
                ],
                axis_labels: {
                    x: "Contraintes SOURCE (D√©biteur)",
                    y: "Contraintes TARGET (Cr√©diteur)",
                    z: "Contraintes SECONDARY (Bonus/Malus)"
                },
                simplex_states: [
                    {
                        step: 0,
                        coordinates: [825, 780, 150],
                        is_feasible: true,
                        is_optimal: false,
                        timestamp: 0.0
                    },
                    {
                        step: 1,
                        coordinates: [432, 300, 30],
                        is_feasible: true,
                        is_optimal: false,
                        timestamp: 100.0
                    },
                    {
                        step: 2,
                        coordinates: [208, 270, 20],
                        is_feasible: true,
                        is_optimal: false,
                        timestamp: 200.0
                    },
                    {
                        step: 3,
                        coordinates: [100, 50, -10],
                        is_feasible: true,
                        is_optimal: true,
                        timestamp: 300.0
                    }
                ]
            };
        }

        // ===== FONCTIONS ANIMATION TEMPORELLE =====

        // Initialisation animation
        function initializeAnimation() {
            if (solutionData && solutionData.simplex_states) {
                animationSteps = solutionData.simplex_states;
                currentAnimationStep = 0;

                // Configurer contr√¥les
                const timeline = document.getElementById('timeline');
                timeline.max = animationSteps.length - 1;
                timeline.value = 0;

                updateStepInfo();
                updateSpeedInfo();

                // Afficher step initial (step 0) avec plans de contraintes
                updatePolytopeWithConstraints(0);

                console.log(`üé¨ Animation initialis√©e: ${animationSteps.length} √©tapes`);
            }
        }

        // Mise √† jour affichage step
        function updateStepInfo() {
            const stepInfo = document.getElementById('stepInfo');
            if (animationSteps.length > 0) {
                stepInfo.textContent = `Step ${currentAnimationStep}/${animationSteps.length - 1}`;
            } else {
                stepInfo.textContent = 'Step 0/0';
            }
        }

        // Mise √† jour affichage vitesse
        function updateSpeedInfo() {
            const speedInfo = document.getElementById('speedInfo');
            speedInfo.textContent = `${animationSpeed}ms`;
        }

        // Nettoyage sc√®ne
        function clearScene() {
            // Supprimer points existants
            solutionPoints.forEach(point => {
                scene.remove(point);
            });
            solutionPoints = [];

            // Supprimer ar√™tes existantes
            simplexEdges.forEach(edge => {
                scene.remove(edge);
            });
            simplexEdges = [];
        }

        // Cr√©ation points pour un step sp√©cifique
        function createSolutionPointsForStep(stepIndex) {
            if (stepIndex >= animationSteps.length) return;
            if (!scene) {
                console.warn('createSolutionPointsForStep: scene non initialis√©e');
                return;
            }

            const currentState = animationSteps[stepIndex];
            const coords = currentState.coordinates;

            // G√©om√©trie point - taille variable selon valeur objective
            const baseSize = config.pointSize;
            const objectiveScale = currentState.objective_value ? Math.log(currentState.objective_value / 100 + 1) : 1;
            const scaledSize = baseSize * (0.5 + objectiveScale * 0.5);
            const geometry = new THREE.SphereGeometry(scaledSize, 16, 12);

            // Couleur selon √©tat avec gradient pour valeur objective
            let color = colors.considered; // D√©faut
            if (currentState.is_optimal) {
                color = colors.optimal;
            } else if (currentState.is_feasible) {
                color = colors.traversed;
            }

            const material = new THREE.MeshBasicMaterial({
                color: color,
                transparent: false,
                opacity: 0.8
            });
            const point = new THREE.Mesh(geometry, material);

            // Position dans l'espace 3D - Centrage am√©lior√©
            // Centrer autour des valeurs moyennes typiques des donn√©es ICGS
            const centerX = 500; // Centre X autour de 500 (valeurs typiques 0-1000)
            const centerY = 400; // Centre Y autour de 400 (valeurs typiques 0-800)
            const centerZ = 200; // Centre Z autour de 200 (valeurs typiques 0-400)

            const transformedX = (coords[0] - centerX) * 0.6;
            const transformedY = (coords[1] - centerY) * 0.6;
            const transformedZ = (coords[2] - centerZ) * 0.6;

            point.position.set(transformedX, transformedY, transformedZ);

            // üîç DEBUG: Transformation points (afficher seulement le premier)
            if (stepIndex === 0) {
                console.log('üîç DEBUG createSolutionPointsForStep:');
                console.log('  - Step:', stepIndex);
                console.log('  - Original coords:', coords);
                console.log('  - Centers (X,Y,Z):', centerX, centerY, centerZ);
                console.log('  - Transformed pos:', transformedX, transformedY, transformedZ);
                console.log('  - Scale factor: 0.6');
            }

            // M√©tadonn√©es enrichies
            point.userData = {
                step: stepIndex,
                feasible: currentState.is_feasible,
                optimal: currentState.is_optimal,
                coordinates: coords,
                timestamp: currentState.timestamp || (stepIndex * 100),
                variables_fi: currentState.variables_fi || {},
                constraint_contributions: currentState.constraint_contributions || {},
                basic_variables: currentState.basic_variables || [],
                objective_value: currentState.objective_value || 0
            };

            scene.add(point);
            solutionPoints.push(point);
        }

        // Cr√©ation ar√™tes pour un step sp√©cifique
        function createSimplexEdgesForStep(stepIndex) {
            if (stepIndex === 0) return; // Pas d'ar√™te pour le premier point
            if (!scene) {
                console.warn('createSimplexEdgesForStep: scene non initialis√©e');
                return;
            }

            const currentState = animationSteps[stepIndex];
            const previousState = animationSteps[stepIndex - 1];

            // Cr√©er ar√™te entre point pr√©c√©dent et actuel - Transformation coh√©rente
            const centerX = 500, centerY = 400, centerZ = 200; // M√™mes centres que pour les points
            const scale = 0.6;

            const points = [
                new THREE.Vector3(
                    (previousState.coordinates[0] - centerX) * scale,
                    (previousState.coordinates[1] - centerY) * scale,
                    (previousState.coordinates[2] - centerZ) * scale
                ),
                new THREE.Vector3(
                    (currentState.coordinates[0] - centerX) * scale,
                    (currentState.coordinates[1] - centerY) * scale,
                    (currentState.coordinates[2] - centerZ) * scale
                )
            ];

            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({
                color: colors.edgeTraversed,
                linewidth: 2
            });

            const line = new THREE.Line(geometry, material);

            // M√©tadonn√©es
            line.userData = {
                fromStep: stepIndex - 1,
                toStep: stepIndex,
                edgeType: 'traversed'
            };

            scene.add(line);
            simplexEdges.push(line);
        }

        // Mise √† jour polytope pour un step donn√©
        function updatePolytope(stepIndex) {
            if (stepIndex >= animationSteps.length) return;

            // Nettoyage
            clearScene();

            // Recr√©er sc√®ne pour √©tapes jusqu'√† stepIndex
            for (let i = 0; i <= stepIndex; i++) {
                createSolutionPointsForStep(i);
                if (i > 0) {
                    createSimplexEdgesForStep(i);
                }
            }

            // Mettre √† jour affichage
            updateStepInfo();
            currentAnimationStep = stepIndex;
        }

        // Animation automatique
        function playAnimation() {
            if (currentAnimationStep < animationSteps.length - 1) {
                currentAnimationStep++;
                updatePolytopeWithConstraints(currentAnimationStep);
                document.getElementById('timeline').value = currentAnimationStep;
            } else {
                stopAnimation(); // Arr√™ter √† la fin
            }
        }

        // D√©marrer animation
        function startAnimation() {
            if (isAnimationPlaying) return;

            isAnimationPlaying = true;
            document.getElementById('playPause').textContent = '‚è∏Ô∏è Pause';

            animationInterval = setInterval(playAnimation, animationSpeed);
        }

        // Arr√™ter animation
        function stopAnimation() {
            if (!isAnimationPlaying) return;

            isAnimationPlaying = false;
            document.getElementById('playPause').textContent = '‚ñ∂Ô∏è Play Animation';

            if (animationInterval) {
                clearInterval(animationInterval);
                animationInterval = null;
            }
        }

        // Toggle play/pause
        function toggleAnimation() {
            if (isAnimationPlaying) {
                stopAnimation();
            } else {
                startAnimation();
            }
        }

        // ===== FONCTIONS VISUALISATION POLYTOPE =====

        // Cr√©ation plans de contraintes
        function createConstraintPlanes(stepIndex) {
            if (!solutionData.constraint_planes || !showConstraintPlanes) return;
            if (!scene) {
                console.warn('createConstraintPlanes: scene non initialis√©e');
                return;
            }

            solutionData.constraint_planes.forEach((plane, index) => {
                // V√©rifier si plan actif pour ce step
                if (plane.active_steps && !plane.active_steps.includes(stepIndex)) return;

                // Cr√©er g√©om√©trie plan
                const size = 800; // Taille du plan
                const geometry = new THREE.PlaneGeometry(size, size);

                // Couleur selon type de contrainte
                const colors_planes = {
                    'SOURCE': 0xff6b6b,      // Rouge clair
                    'TARGET': 0x4ecdc4,      // Cyan
                    'SECONDARY': 0xffa726    // Orange
                };
                const planeColor = colors_planes[plane.type] || 0x888888;

                const material = new THREE.MeshBasicMaterial({
                    color: planeColor,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.15,
                    wireframe: false
                });

                const planeMesh = new THREE.Mesh(geometry, material);

                // Position et orientation selon l'√©quation ax + by + cz = d
                const eq = plane.equation;
                if (eq.a === 1 && eq.b === 0 && eq.c === 0) {
                    // Plan vertical X = d
                    planeMesh.rotation.y = Math.PI / 2;
                    planeMesh.position.set(eq.d - 500, 0, 0);
                } else if (eq.a === 0 && eq.b === 1 && eq.c === 0) {
                    // Plan vertical Y = d
                    planeMesh.rotation.x = Math.PI / 2;
                    planeMesh.position.set(0, eq.d - 400, 0);
                } else if (eq.a === 0 && eq.b === 0 && eq.c === 1) {
                    // Plan horizontal Z = d
                    planeMesh.position.set(0, 0, eq.d);
                }

                // Wireframe pour les bords
                const wireframeGeometry = new THREE.EdgesGeometry(geometry);
                const wireframeMaterial = new THREE.LineBasicMaterial({
                    color: planeColor,
                    opacity: 0.5,
                    transparent: true
                });
                const wireframe = new THREE.LineSegments(wireframeGeometry, wireframeMaterial);
                wireframe.position.copy(planeMesh.position);
                wireframe.rotation.copy(planeMesh.rotation);

                // M√©tadonn√©es
                planeMesh.userData = {
                    constraintType: plane.type,
                    equation: plane.equation,
                    bounds: plane.bounds,
                    step: stepIndex,
                    isConstraintPlane: true
                };

                wireframe.userData = {
                    constraintType: plane.type,
                    isWireframe: true,
                    parentPlane: planeMesh
                };

                scene.add(planeMesh);
                scene.add(wireframe);
                meshPoints.push(planeMesh);
                meshPoints.push(wireframe);
            });
        }

        // Nettoyage plans contraintes
        function clearConstraintPlanes() {
            const planesToRemove = meshPoints.filter(mesh =>
                mesh.userData.isConstraintPlane || mesh.userData.isWireframe
            );

            planesToRemove.forEach(plane => {
                scene.remove(plane);
            });

            // Garder seulement les objets qui ne sont pas des plans
            meshPoints = meshPoints.filter(mesh =>
                !mesh.userData.isConstraintPlane && !mesh.userData.isWireframe
            );
        }

        // Mise √† jour polytope avec plans de contraintes
        function updatePolytopeWithConstraints(stepIndex) {
            if (stepIndex >= animationSteps.length) return;

            // Nettoyage
            clearScene();
            clearConstraintPlanes();

            // Recr√©er points et ar√™tes
            for (let i = 0; i <= stepIndex; i++) {
                createSolutionPointsForStep(i);
                if (i > 0) {
                    createSimplexEdgesForStep(i);
                }
            }

            // Ajouter plans de contraintes pour step actuel
            createConstraintPlanes(stepIndex);

            // Mettre √† jour affichage
            updateStepInfo();
            currentAnimationStep = stepIndex;
        }

        // Initialisation Three.js
        function initThreeJS() {
            const container = document.getElementById('canvas-container');

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);

            // Camera
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                1,
                10000
            );
            // Position cam√©ra ajust√©e pour nouveau centrage
            camera.position.set(400, 300, 400);

            // FORCER la cam√©ra √† regarder l'origine (0,0,0)
            camera.lookAt(0, 0, 0);

            // üîç DEBUG: Cam√©ra et scene
            console.log('üîç DEBUG initThreeJS:');
            console.log('  - Camera position:', camera.position);
            console.log('  - Camera FOV:', camera.fov);
            console.log('  - Scene background:', scene.background);
            console.log('  - ‚úÖ Camera.lookAt(0,0,0) forc√© pour centrer sur origine');

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            // Lumi√®res
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1000, 1000, 500);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // Controls
            if (typeof THREE.OrbitControls !== 'undefined') {
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.enableZoom = true;

                // FORCER OrbitControls √† cibler l'origine (0,0,0)
                controls.target.set(0, 0, 0);
                controls.update();

                // üîç DEBUG: OrbitControls configuration
                console.log('üîç DEBUG OrbitControls:');
                console.log('  - Target (center of rotation):', controls.target);
                console.log('  - Camera looks at origin:', controls.target.x === 0 && controls.target.y === 0 && controls.target.z === 0);
                console.log('  - Distance from target:', camera.position.distanceTo(controls.target));

                console.log('‚úÖ OrbitControls initialis√©s et forc√©s sur origine (0,0,0)');
            } else {
                console.warn('‚ö†Ô∏è OrbitControls indisponibles, rotation basique activ√©e');
                console.log('‚ö†Ô∏è Mais camera.lookAt(0,0,0) d√©j√† appliqu√© pour centrer sur origine');
                controls = null;
            }

            // Resize handler
            window.addEventListener('resize', onWindowResize);

            // Mouse events
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('click', onMouseClick);
        }

        // Cr√©ation axes 3D centr√©s
        function createAxes() {
            const axisLength = 600;
            const axisOffset = axisLength / 2; // Centrer les axes autour de l'origine

            // Axe X (rouge) centr√©
            const xPoints = [
                new THREE.Vector3(-axisOffset, 0, 0),
                new THREE.Vector3(axisOffset, 0, 0)
            ];
            const xGeometry = new THREE.BufferGeometry().setFromPoints(xPoints);
            const xLine = new THREE.Line(xGeometry, new THREE.LineBasicMaterial({ color: 0xff0000 }));
            scene.add(xLine);

            // Axe Y (vert) centr√©
            const yPoints = [
                new THREE.Vector3(0, -axisOffset, 0),
                new THREE.Vector3(0, axisOffset, 0)
            ];
            const yGeometry = new THREE.BufferGeometry().setFromPoints(yPoints);
            const yLine = new THREE.Line(yGeometry, new THREE.LineBasicMaterial({ color: 0x00ff00 }));
            scene.add(yLine);

            // Axe Z (bleu) centr√©
            const zPoints = [
                new THREE.Vector3(0, 0, -axisOffset),
                new THREE.Vector3(0, 0, axisOffset)
            ];
            const zGeometry = new THREE.BufferGeometry().setFromPoints(zPoints);
            const zLine = new THREE.Line(zGeometry, new THREE.LineBasicMaterial({ color: 0x0000ff }));
            scene.add(zLine);

            // Marquer l'origine avec une sph√®re visible
            const originGeometry = new THREE.SphereGeometry(8, 16, 16); // Plus grande et plus d√©taill√©e
            const originMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                wireframe: true,  // Wireframe pour mieux la voir
                transparent: false
            });
            const originMarker = new THREE.Mesh(originGeometry, originMaterial);
            originMarker.position.set(0, 0, 0);
            scene.add(originMarker);

            // Ajouter aussi une sph√®re pleine plus petite au centre
            const originCoreGeometry = new THREE.SphereGeometry(3, 8, 8);
            const originCoreMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 }); // Rouge pour contraste
            const originCore = new THREE.Mesh(originCoreGeometry, originCoreMaterial);
            originCore.position.set(0, 0, 0);
            scene.add(originCore);

            // üîç DEBUG: Position origine et axes
            console.log('üîç DEBUG createAxes:');
            console.log('  - Origin marker position:', originMarker.position);
            console.log('  - Axes length:', axisLength);
            console.log('  - Axes offset:', axisOffset);
            console.log('  - X axis: from', -axisOffset, 'to', axisOffset);
            console.log('  - Y axis: from', -axisOffset, 'to', axisOffset);
            console.log('  - Z axis: from', -axisOffset, 'to', axisOffset);
        }

        // Cr√©ation points solutions
        function createSolutionPoints() {
            solutionPoints = [];

            // Compatibilit√© avec nouvelle structure donn√©es polytope (simplex_states)
            const dataPoints = solutionData.solution_points || solutionData.simplex_states || [];

            if (dataPoints.length === 0) {
                console.warn('createSolutionPoints: Aucune donn√©e de points disponible');
                return;
            }

            dataPoints.forEach(point => {
                // V√©rification structure du point
                if (!point.coordinates || !Array.isArray(point.coordinates) || point.coordinates.length < 3) {
                    console.warn('createSolutionPoints: Point avec coordonn√©es invalides', point);
                    return;
                }

                const [x, y, z] = point.coordinates;

                // G√©om√©trie et mat√©riel selon statut
                const geometry = new THREE.SphereGeometry(config.pointSize, 32, 32);
                let color;

                // Couleur selon type de pivot
                if (point.pivot_type) {
                    switch(point.pivot_type) {
                        case 'optimal':
                            color = colors.optimal;
                            break;
                        case 'traversed':
                            color = colors.traversed;
                            break;
                        case 'considered':
                            color = colors.considered;
                            break;
                        default:
                            color = colors.infeasible;
                    }
                } else {
                    // Fallback pour structures multiples (optimal/feasible ou is_optimal/is_feasible)
                    if (point.optimal || point.is_optimal) {
                        color = colors.optimal;
                    } else if (point.feasible || point.is_feasible) {
                        color = colors.traversed;
                    } else {
                        color = colors.infeasible;
                    }
                }

                const material = new THREE.MeshLambertMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.8
                });

                const sphere = new THREE.Mesh(geometry, material);

                // Position avec transformation coh√©rente pour centrage
                const centerX = 500, centerY = 400, centerZ = 200;
                const scale = 0.6;
                sphere.position.set(
                    (x - centerX) * scale,
                    (y - centerY) * scale,
                    (z - centerZ) * scale
                );
                sphere.userData = point;
                sphere.castShadow = true;
                sphere.receiveShadow = true;

                scene.add(sphere);
                solutionPoints.push(sphere);
            });
        }

        // Cr√©ation des ar√™tes entre pivots du Simplex
        function createSimplexEdges() {
            simplexEdges = [];

            if (!solutionData.simplex_edges) {
                console.log('Aucune ar√™te Simplex trouv√©e dans les donn√©es');
                return;
            }

            solutionData.simplex_edges.forEach(edge => {
                const [fromX, fromY, fromZ] = edge.from_coordinates;
                const [toX, toY, toZ] = edge.to_coordinates;

                // Cr√©er g√©om√©trie ligne
                const geometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(fromX, fromY, fromZ),
                    new THREE.Vector3(toX, toY, toZ)
                ]);

                // Mat√©riau selon type d'ar√™te
                let material;
                let lineWidth = 2;

                switch(edge.edge_type) {
                    case 'traversed':
                        material = new THREE.LineBasicMaterial({
                            color: colors.edgeTraversed,
                            linewidth: lineWidth * 2,
                            transparent: true,
                            opacity: 0.9
                        });
                        break;
                    case 'considered':
                        material = new THREE.LineDashedMaterial({
                            color: colors.edgeConsidered,
                            linewidth: lineWidth,
                            dashSize: 10,
                            gapSize: 5,
                            transparent: true,
                            opacity: 0.6
                        });
                        break;
                    default: // rejected
                        material = new THREE.LineDashedMaterial({
                            color: colors.edgeRejected,
                            linewidth: lineWidth,
                            dashSize: 5,
                            gapSize: 10,
                            transparent: true,
                            opacity: 0.3
                        });
                }

                const line = new THREE.Line(geometry, material);

                // Calculer les tirets pour les lignes pointill√©es
                if (edge.edge_type !== 'traversed') {
                    line.computeLineDistances();
                }

                // Ajouter m√©tadonn√©es
                line.userData = {
                    edgeType: edge.edge_type,
                    pivotDirection: edge.pivot_direction,
                    improvement: edge.improvement,
                    fromStep: edge.from_step,
                    toStep: edge.to_step
                };

                scene.add(line);
                simplexEdges.push(line);
            });

            console.log(`‚úÖ ${simplexEdges.length} ar√™tes Simplex cr√©√©es`);
        }

        // Configuration contr√¥les UI
        function setupControls() {
            // Vitesse rotation
            document.getElementById('rotationSpeed').addEventListener('input', (e) => {
                config.rotationSpeed = parseFloat(e.target.value) * 0.01;
            });

            // Taille points
            document.getElementById('pointSize').addEventListener('input', (e) => {
                config.pointSize = parseFloat(e.target.value);
                updatePointSizes();
            });

            // Mode visualisation
            document.getElementById('viewMode').addEventListener('change', (e) => {
                config.viewMode = e.target.value;
                updateViewMode();
            });

            // Reset cam√©ra
            document.getElementById('resetCamera').addEventListener('click', () => {
                // Position cam√©ra ajust√©e pour nouveau centrage
                camera.position.set(400, 300, 400);
                camera.lookAt(0, 0, 0); // FORCER regard vers origine

                if (controls) {
                    controls.target.set(0, 0, 0); // FORCER target OrbitControls sur origine
                    controls.update();
                } else {
                    console.log('üì∑ Camera reset sans OrbitControls - camera.lookAt(0,0,0) appliqu√©');
                }

                console.log('üì∑ Camera reset - Position:', camera.position, 'Target: (0,0,0)');
            });

            // G√©n√©rer maillage
            document.getElementById('generateMesh').addEventListener('click', generateMesh);

            // Nouvelle analyse
            document.getElementById('analyzeNew').addEventListener('click', runNewAnalysis);

            // ===== EVENT LISTENERS ANIMATION TEMPORELLE =====

            // Timeline scrubber
            document.getElementById('timeline').addEventListener('input', (e) => {
                const stepIndex = parseInt(e.target.value);
                updatePolytopeWithConstraints(stepIndex);
                // Arr√™ter animation si en cours
                if (isAnimationPlaying) {
                    stopAnimation();
                }
            });

            // Play/Pause animation
            document.getElementById('playPause').addEventListener('click', toggleAnimation);

            // Vitesse animation
            document.getElementById('animSpeed').addEventListener('input', (e) => {
                animationSpeed = parseInt(e.target.value);
                updateSpeedInfo();

                // Si animation en cours, red√©marrer avec nouvelle vitesse
                if (isAnimationPlaying) {
                    stopAnimation();
                    startAnimation();
                }
            });

            // Toggle plans de contraintes
            document.getElementById('toggleConstraints').addEventListener('click', (e) => {
                showConstraintPlanes = !showConstraintPlanes;
                e.target.textContent = showConstraintPlanes ?
                    'üìê Masquer Plans Contraintes' : 'üìê Afficher Plans Contraintes';

                // Rafra√Æchir affichage
                updatePolytopeWithConstraints(currentAnimationStep);
            });
        }

        // Mise √† jour taille points
        function updatePointSizes() {
            solutionPoints.forEach(point => {
                point.scale.setScalar(config.pointSize / 3);
            });
        }

        // Mise √† jour mode visualisation
        function updateViewMode() {
            // TODO: Impl√©menter diff√©rents modes
            console.log('Mode visualisation:', config.viewMode);
        }

        // G√©n√©ration maillage
        function generateMesh() {
            console.log('üî≥ G√©n√©ration maillage 3D...');
            // TODO: Impl√©menter g√©n√©ration maillage faisable
        }

        // Nouvelle analyse
        async function runNewAnalysis() {
            showLoading();
            try {
                const response = await fetch('/api/simulation/analyze_3d');
                if (response.ok) {
                    const newData = await response.json();
                    solutionData = newData;
                    refreshVisualization();
                }
            } catch (error) {
                console.error('Erreur nouvelle analyse:', error);
            }
            hideLoading();
        }

        // Actualisation visualisation
        function refreshVisualization() {
            // Supprimer anciens points
            solutionPoints.forEach(point => scene.remove(point));

            // Recr√©er points
            createSolutionPoints();
            updateStats();
        }

        // Gestion souris
        function onMouseMove(event) {
            // TODO: Impl√©menter hover tooltip
        }

        function onMouseClick(event) {
            // TODO: Impl√©menter s√©lection point
        }

        // Resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Animation
        function animate() {
            animationId = requestAnimationFrame(animate);

            // Rotation automatique
            if (config.rotationSpeed > 0) {
                scene.rotation.y += config.rotationSpeed;
            }

            // Mise √† jour contr√¥les si disponibles
            if (controls && controls.update) {
                controls.update();
            }

            renderer.render(scene, camera);
        }

        // Mise √† jour statistiques
        function updateStats() {
            if (!solutionData) return;

            const meta = solutionData.metadata;
            document.getElementById('totalPoints').textContent = meta.total_points;
            document.getElementById('feasiblePoints').textContent = meta.feasible_points;
            document.getElementById('optimalPoints').textContent = meta.optimal_points;

            const successRate = meta.total_points > 0 ?
                (meta.feasible_points / meta.total_points * 100).toFixed(1) : 0;
            document.getElementById('successRate').textContent = successRate + '%';
        }

        // Loading
        function showLoading() {
            document.getElementById('loading').style.display = 'block';
        }

        function hideLoading() {
            document.getElementById('loading').style.display = 'none';
        }

        function showError(error) {
            document.getElementById('loading').innerHTML = `
                <h2>‚ùå Erreur Chargement</h2>
                <p>${error.message}</p>
                <button onclick="location.reload()" style="margin-top: 15px; padding: 10px 20px; border: none; border-radius: 5px; background: #e74c3c; color: white; cursor: pointer;">
                    üîÑ Recharger
                </button>
            `;
        }

        console.log('üåå ICGS 3D Visualizer initialized');
    </script>
</body>
</html>