<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CAPS - Constraint-Adaptive Path Simplex</title>
    <link rel="stylesheet" href="/static/styles.css">

    <!-- D3.js pour les visualisations SVG -->
    <script src="https://d3js.org/d3.v7.min.js"></script>

    <style>
        .caps-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: white;
        }

        .caps-header {
            text-align: center;
            margin-bottom: 40px;
            padding: 30px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }

        .caps-title {
            font-size: 3.5em;
            font-weight: bold;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .caps-subtitle {
            font-size: 1.4em;
            opacity: 0.9;
            margin-bottom: 20px;
        }

        .caps-description {
            font-size: 1.1em;
            line-height: 1.6;
            max-width: 800px;
            margin: 0 auto;
            opacity: 0.8;
        }

        .technical-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 30px;
            margin: 40px 0;
        }

        .technical-card {
            background: rgba(255, 255, 255, 0.1);
            padding: 25px;
            border-radius: 12px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: transform 0.3s ease;
        }

        .technical-card:hover {
            transform: translateY(-5px);
            background: rgba(255, 255, 255, 0.15);
        }

        .technical-card h3 {
            color: #4ecdc4;
            margin-bottom: 15px;
            font-size: 1.4em;
        }

        .svg-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 8px;
            margin: 15px 0;
            padding: 10px;
            min-height: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .animation-progress-section {
            margin: 20px 0;
            padding: 20px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .progress-container {
            margin-bottom: 20px;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .progress-text {
            text-align: center;
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.8);
        }

        .current-transaction-panel {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #4ecdc4;
        }

        .current-transaction-panel h5 {
            margin: 0 0 10px 0;
            color: #4ecdc4;
        }

        .transaction-details {
            font-size: 0.95em;
            line-height: 1.4;
        }

        .simulation-access {
            background: rgba(255, 255, 255, 0.1);
            padding: 30px;
            border-radius: 15px;
            margin: 40px 0;
            text-align: center;
        }

        .simulation-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 20px;
        }

        .sim-button {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            color: white;
            font-weight: bold;
            font-size: 1.1em;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
        }

        .sim-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
            background: linear-gradient(45deg, #44a08d, #4ecdc4);
        }

        .realtime-section {
            margin: 40px 0;
        }

        .realtime-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .realtime-widget {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(5px);
        }

        .widget-title {
            color: #ff6b6b;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #4ecdc4;
            margin-right: 8px;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        /* Nouveaux styles pour l'animation am√©lior√©e */
        .transaction-current-display {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
            border-left: 4px solid #4ecdc4;
            transition: all 0.3s ease;
        }

        .transaction-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .transaction-progress-percent {
            background: rgba(78, 205, 196, 0.2);
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.8em;
            font-weight: bold;
            color: #4ecdc4;
        }

        .transaction-flow {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
            font-size: 1.1em;
        }

        .source-agent, .target-agent {
            background: rgba(78, 205, 196, 0.1);
            padding: 4px 8px;
            border-radius: 8px;
            font-weight: bold;
        }

        .arrow {
            color: #4ecdc4;
            font-size: 1.2em;
            font-weight: bold;
        }

        .transaction-details {
            display: flex;
            gap: 15px;
            margin: 8px 0;
            font-size: 0.9em;
        }

        .amount {
            color: #28a745;
            font-weight: bold;
        }

        .flow-type {
            color: #6c757d;
            font-style: italic;
        }

        .transaction-timing {
            color: #6c757d;
            font-size: 0.8em;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding-top: 8px;
            margin-top: 8px;
        }

        .initialization-display {
            display: flex;
            align-items: center;
            padding: 20px;
            text-align: center;
        }

        .loading-spinner {
            width: 20px;
            height: 20px;
            border: 2px solid rgba(78, 205, 196, 0.3);
            border-top: 2px solid #4ecdc4;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Am√©lioration des indicateurs de statut */
        .status-value {
            transition: all 0.3s ease;
        }

        #animation-progress-text {
            background: transparent;
            padding: 5px 10px;
            border-radius: 5px;
            transition: background 0.5s ease;
        }

        /* Effet glow pour la barre de progression */
        .transaction-progress {
            box-shadow: 0 0 10px rgba(78, 205, 196, 0.3);
            transition: all 0.8s ease-in-out;
        }

        /* Affichage de completion */
        .completion-display {
            display: flex;
            align-items: center;
            padding: 20px;
            text-align: center;
            background: rgba(40, 167, 69, 0.1);
            border-radius: 10px;
            border: 2px solid rgba(40, 167, 69, 0.3);
        }

        .completion-icon {
            font-size: 2em;
            margin-right: 15px;
            animation: bounce 1s infinite;
        }

        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-10px); }
            60% { transform: translateY(-5px); }
        }

        /* Affichage de r√©cup√©ration d'erreur */
        .error-recovery-display {
            padding: 20px;
            text-align: center;
            background: rgba(220, 53, 69, 0.1);
            border-radius: 10px;
            border: 2px solid rgba(220, 53, 69, 0.3);
        }

        .error-recovery-display button {
            margin-top: 10px;
            animation: pulse 2s infinite;
        }

        /* Enhanced Animation Controls */
        .enhanced-controls {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            align-items: center;
            justify-content: space-between;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .manual-step-controls, .speed-controls, .jump-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .control-label {
            font-size: 0.9em;
            color: #4ecdc4;
            font-weight: bold;
            white-space: nowrap;
        }

        .step-btn, .speed-btn, .jump-btn {
            padding: 8px 12px;
            font-size: 0.9em;
            min-width: 40px;
        }

        .step-btn {
            background: linear-gradient(45deg, #6f42c1, #8e44ad);
            color: white;
        }

        .speed-btn {
            background: linear-gradient(45deg, #17a2b8, #20c997);
            color: white;
            transition: all 0.3s ease;
        }

        .speed-btn.active {
            background: linear-gradient(45deg, #28a745, #20c997);
            box-shadow: 0 0 10px rgba(40, 167, 69, 0.5);
            transform: scale(1.05);
        }

        .jump-btn {
            background: linear-gradient(45deg, #fd7e14, #ffc107);
            color: white;
        }

        .step-input {
            width: 60px;
            padding: 6px 8px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            text-align: center;
            font-size: 0.9em;
        }

        .step-input:focus {
            outline: none;
            border-color: #4ecdc4;
            box-shadow: 0 0 5px rgba(78, 205, 196, 0.5);
        }

        .step-input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        /* Progress bar interactive */
        .progress-container {
            cursor: pointer;
            position: relative;
        }

        .progress-bar:hover {
            box-shadow: 0 0 15px rgba(78, 205, 196, 0.6);
        }

        /* Responsive design for enhanced controls */
        @media (max-width: 768px) {
            .enhanced-controls {
                flex-direction: column;
                gap: 15px;
            }

            .manual-step-controls, .speed-controls, .jump-controls {
                justify-content: center;
                width: 100%;
            }
        }

        .nav-back {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            color: white;
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }

        .nav-back:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        /* Styles pour la section Interactive Simulation */
        .interactive-simulation-section {
            margin: 40px 0;
            background: rgba(255, 255, 255, 0.05);
            padding: 30px;
            border-radius: 15px;
            border: 2px solid rgba(255, 255, 255, 0.1);
        }

        .interactive-simulation-section h2 {
            color: #4ecdc4;
            margin-bottom: 15px;
            font-size: 2em;
            text-align: center;
        }

        .simulation-control-panel {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 20px;
        }

        .control-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .control-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 20px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9em;
        }

        .start-btn {
            background: linear-gradient(45deg, #28a745, #20c997);
            color: white;
        }

        .pause-btn {
            background: linear-gradient(45deg, #ffc107, #fd7e14);
            color: white;
        }

        .stop-btn {
            background: linear-gradient(45deg, #dc3545, #e83e8c);
            color: white;
        }

        .reset-btn {
            background: linear-gradient(45deg, #6f42c1, #e83e8c);
            color: white;
        }

        .control-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .simulation-status {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .status-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .status-label {
            font-size: 0.8em;
            opacity: 0.7;
            margin-bottom: 5px;
        }

        .status-value {
            font-weight: bold;
            font-size: 1.1em;
            color: #4ecdc4;
        }

        .live-svg-animations {
            margin: 30px 0;
        }

        .animation-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
        }

        .animation-widget {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 12px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .animation-widget h4 {
            color: #ff6b6b;
            margin-bottom: 15px;
            text-align: center;
        }

        .svg-animation-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 8px;
            padding: 10px;
            min-height: 250px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .live-svg-content {
            width: 100%;
            height: 100%;
            min-height: 230px;
        }

        .transaction-selector {
            margin-top: 10px;
        }

        .transaction-selector select {
            width: 100%;
            padding: 8px;
            border-radius: 5px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 0.9em;
        }

        .transaction-selector select option {
            background: #333;
            color: white;
        }

        @keyframes pulse-live {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        .live-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #28a745;
            margin-right: 5px;
            animation: pulse-live 1.5s infinite;
        }
    </style>
</head>
<body>
    <button class="nav-back" onclick="window.location.href='/'">‚Üê Retour ICGS 3D</button>

    <div class="caps-container">
        <header class="caps-header">
            <h1 class="caps-title">CAPS</h1>
            <h2 class="caps-subtitle">Constraint-Adaptive Path Simplex</h2>
            <p class="caps-description">
                Syst√®me d'optimisation avanc√© combinant la programmation lin√©aire Simplex avec des contraintes adaptatives
                et une exploration de chemins optimaux pour la simulation √©conomique massive.
            </p>
        </header>

        <div class="technical-grid">
            <div class="technical-card">
                <h3>üîó Constraint-Adaptive</h3>
                <p>Adaptation dynamique des contraintes selon l'√©tat du syst√®me √©conomique. Les contraintes de capacit√©, de flux et de balance s'ajustent automatiquement selon les conditions de march√©.</p>
                <div class="svg-container">
                    <svg id="constraint-viz" width="300" height="150"></svg>
                </div>
                <div class="widget-title">
                    <span class="status-indicator"></span>Contraintes Actives: <span id="active-constraints">7</span>
                </div>
            </div>

            <div class="technical-card">
                <h3>üõ§Ô∏è Path Optimization</h3>
                <p>Recherche de chemins optimaux dans le graphe √©conomique pour minimiser les co√ªts de transaction et maximiser l'efficacit√© des flux financiers entre agents.</p>
                <div class="svg-container">
                    <svg id="path-viz" width="300" height="150"></svg>
                </div>
                <div class="widget-title">
                    <span class="status-indicator"></span>Chemins Explor√©s: <span id="paths-explored">142</span>
                </div>
            </div>

            <div class="technical-card">
                <h3>üìê Simplex Algorithm</h3>
                <p>Impl√©mentation de l'algorithme Simplex pour r√©soudre les probl√®mes d'optimisation lin√©aire multi-objectifs avec variables continues et discr√®tes.</p>
                <div class="svg-container">
                    <svg id="simplex-viz" width="300" height="150"></svg>
                </div>
                <div class="widget-title">
                    <span class="status-indicator"></span>It√©rations: <span id="simplex-iterations">23</span>
                </div>
            </div>
        </div>

        <div class="simulation-access">
            <h2>üöÄ Acc√®s aux Simulations</h2>
            <p>Explorez les capacit√©s CAPS avec nos simulations interactives</p>
            <div class="simulation-buttons">
                <a href="/" class="sim-button">Interface 3D Compl√®te</a>
                <button class="sim-button" onclick="load65AgentsSimulation()">Simulation 65 Agents</button>
                <button class="sim-button" onclick="openAdvancedMode()">Mode Avanc√© CAPS</button>
            </div>
        </div>

        <div class="interactive-simulation-section">
            <h2>üé¨ Simulation Interactive 65 Agents</h2>
            <p>D√©monstration temps r√©el du syst√®me CAPS avec animation SVG bas√©e sur de vraies donn√©es √©conomiques</p>

            <div class="simulation-control-panel">
                <div class="control-buttons">
                    <button id="start-simulation-btn" class="control-btn start-btn">‚ñ∂Ô∏è D√©marrer Simulation</button>
                    <button id="pause-simulation-btn" class="control-btn pause-btn" disabled>‚è∏Ô∏è Pause</button>
                    <button id="stop-simulation-btn" class="control-btn stop-btn" disabled>‚èπÔ∏è Arr√™ter</button>
                    <button id="reset-simulation-btn" class="control-btn reset-btn">üîÑ Reset</button>
                </div>

                <div class="enhanced-controls">
                    <div class="manual-step-controls">
                        <span class="control-label">üì∫ Contr√¥le Manuel:</span>
                        <button id="step-backward-btn" class="control-btn step-btn" disabled title="√âtape pr√©c√©dente">‚èÆÔ∏è</button>
                        <button id="step-forward-btn" class="control-btn step-btn" disabled title="√âtape suivante">‚è≠Ô∏è</button>
                        <button id="single-step-btn" class="control-btn step-btn" disabled title="Une seule √©tape">‚èØÔ∏è</button>
                    </div>

                    <div class="speed-controls">
                        <span class="control-label">‚ö° Vitesse:</span>
                        <button id="speed-slow-btn" class="control-btn speed-btn" title="Lent (4s)">üêå</button>
                        <button id="speed-normal-btn" class="control-btn speed-btn active" title="Normal (2s)">üö∂</button>
                        <button id="speed-fast-btn" class="control-btn speed-btn" title="Rapide (1s)">üèÉ</button>
                        <button id="speed-ultra-btn" class="control-btn speed-btn" title="Ultra (0.5s)">‚ö°</button>
                    </div>

                    <div class="jump-controls">
                        <span class="control-label">üéØ Aller √†:</span>
                        <input type="number" id="jump-step-input" class="step-input" min="1" max="33" placeholder="N¬∞" title="Num√©ro d'√©tape">
                        <button id="jump-step-btn" class="control-btn jump-btn" disabled title="Aller √† l'√©tape">üéØ</button>
                    </div>
                </div>

                <div class="simulation-status">
                    <div class="status-item">
                        <span class="status-label">√âtat:</span>
                        <span id="simulation-state" class="status-value">Arr√™t√©e</span>
                    </div>
                    <div class="status-item">
                        <span class="status-label">Agents:</span>
                        <span id="active-agents-count" class="status-value">0</span>
                    </div>
                    <div class="status-item">
                        <span class="status-label">Transactions:</span>
                        <span id="total-transactions-count" class="status-value">0</span>
                    </div>
                </div>

                <div class="animation-progress-section">
                    <div class="progress-container">
                        <div class="progress-bar">
                            <div class="transaction-progress" style="width: 0%; background: linear-gradient(45deg, #4ecdc4, #45b7d1); height: 100%; border-radius: 4px; transition: width 0.3s ease;"></div>
                        </div>
                        <div class="progress-text">
                            <span id="animation-progress-text">Pr√™t pour l'animation</span>
                        </div>
                    </div>

                    <div class="current-transaction-panel">
                        <h5>üîÑ Transaction Courante</h5>
                        <div id="current-transaction-display" class="transaction-details">
                            <div style="color: #666; text-align: center; padding: 20px;">
                                Cliquez sur "D√©marrer Simulation" pour commencer l'animation
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="live-svg-animations">
                <div class="animation-grid">
                    <div class="animation-widget">
                        <h4>üåê √âconomie Compl√®te</h4>
                        <div class="svg-animation-container">
                            <div id="economy-animation-svg" class="live-svg-content"></div>
                        </div>
                    </div>

                    <div class="animation-widget">
                        <h4>üìä Dashboard Performance</h4>
                        <div class="svg-animation-container">
                            <div id="performance-dashboard-svg" class="live-svg-content"></div>
                        </div>
                    </div>

                    <div class="animation-widget">
                        <h4>üìê √âtapes Simplex</h4>
                        <div class="svg-animation-container">
                            <div id="simplex-steps-svg" class="live-svg-content"></div>
                        </div>
                    </div>

                    <div class="animation-widget">
                        <h4>üí± Transaction Active</h4>
                        <div class="svg-animation-container">
                            <div id="transaction-detail-svg" class="live-svg-content"></div>
                        </div>
                        <div class="transaction-selector">
                            <select id="transaction-selector">
                                <option value="">S√©lectionner transaction...</option>
                            </select>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="realtime-section">
            <h2>üìä M√©triques Temps R√©el</h2>
            <div class="realtime-grid">
                <div class="realtime-widget">
                    <div class="widget-title">Volume de Transactions</div>
                    <div id="transaction-volume">0</div>
                    <div class="svg-container">
                        <svg id="volume-chart" width="250" height="100"></svg>
                    </div>
                </div>

                <div class="realtime-widget">
                    <div class="widget-title">Efficacit√© Simplex</div>
                    <div id="simplex-efficiency">0%</div>
                    <div class="svg-container">
                        <svg id="efficiency-gauge" width="250" height="100"></svg>
                    </div>
                </div>

                <div class="realtime-widget">
                    <div class="widget-title">Stabilit√© Syst√®me</div>
                    <div id="system-stability">Stable</div>
                    <div class="svg-container">
                        <svg id="stability-indicator" width="250" height="100"></svg>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Variables globales pour les visualisations
        let constraintData = [];
        let pathData = [];
        let simplexData = [];
        let metricsInterval;

        // Initialisation des visualisations SVG
        function initializeVisualizations() {
            initConstraintVisualization();
            initPathVisualization();
            initSimplexVisualization();
            initRealtimeCharts();
            startMetricsUpdate();
        }

        // Visualisation des contraintes adaptatives
        function initConstraintVisualization() {
            const svg = d3.select("#constraint-viz");
            svg.selectAll("*").remove();

            // Simulation de contraintes dynamiques
            const constraints = [
                {name: "Capacit√©", value: 85, max: 100, color: "#ff6b6b"},
                {name: "Flux", value: 72, max: 100, color: "#4ecdc4"},
                {name: "Balance", value: 93, max: 100, color: "#45b7d1"}
            ];

            const barHeight = 15;
            const barSpacing = 25;

            constraints.forEach((constraint, i) => {
                const y = 30 + i * barSpacing;

                // Barre de fond
                svg.append("rect")
                    .attr("x", 20)
                    .attr("y", y)
                    .attr("width", 200)
                    .attr("height", barHeight)
                    .attr("fill", "#e0e0e0")
                    .attr("rx", 3);

                // Barre de valeur
                svg.append("rect")
                    .attr("x", 20)
                    .attr("y", y)
                    .attr("width", (constraint.value / constraint.max) * 200)
                    .attr("height", barHeight)
                    .attr("fill", constraint.color)
                    .attr("rx", 3);

                // Label
                svg.append("text")
                    .attr("x", 15)
                    .attr("y", y + 12)
                    .attr("text-anchor", "end")
                    .attr("fill", "#333")
                    .attr("font-size", "11px")
                    .text(constraint.name);

                // Valeur
                svg.append("text")
                    .attr("x", 230)
                    .attr("y", y + 12)
                    .attr("fill", "#333")
                    .attr("font-size", "11px")
                    .text(constraint.value + "%");
            });
        }

        // Visualisation des chemins optimaux
        function initPathVisualization() {
            const svg = d3.select("#path-viz");
            svg.selectAll("*").remove();

            // Simulation d'un graphe de chemins
            const nodes = [
                {id: "A", x: 50, y: 50, type: "agriculture"},
                {id: "I", x: 150, y: 30, type: "industry"},
                {id: "S", x: 250, y: 60, type: "services"},
                {id: "F", x: 200, y: 120, type: "finance"}
            ];

            const edges = [
                {source: "A", target: "I", weight: 3},
                {source: "I", target: "S", weight: 2},
                {source: "S", target: "F", weight: 1},
                {source: "A", target: "F", weight: 4}
            ];

            // Dessiner les ar√™tes
            edges.forEach(edge => {
                const source = nodes.find(n => n.id === edge.source);
                const target = nodes.find(n => n.id === edge.target);

                svg.append("line")
                    .attr("x1", source.x)
                    .attr("y1", source.y)
                    .attr("x2", target.x)
                    .attr("y2", target.y)
                    .attr("stroke", "#4ecdc4")
                    .attr("stroke-width", edge.weight)
                    .attr("opacity", 0.7);
            });

            // Dessiner les n≈ìuds
            nodes.forEach(node => {
                svg.append("circle")
                    .attr("cx", node.x)
                    .attr("cy", node.y)
                    .attr("r", 8)
                    .attr("fill", "#ff6b6b")
                    .attr("stroke", "#fff")
                    .attr("stroke-width", 2);

                svg.append("text")
                    .attr("x", node.x)
                    .attr("y", node.y + 4)
                    .attr("text-anchor", "middle")
                    .attr("fill", "white")
                    .attr("font-size", "10px")
                    .attr("font-weight", "bold")
                    .text(node.id);
            });
        }

        // Visualisation de l'algorithme Simplex
        function initSimplexVisualization() {
            const svg = d3.select("#simplex-viz");
            svg.selectAll("*").remove();

            // Simulation d'une r√©gion faisable Simplex
            const width = 300;
            const height = 150;

            // R√©gion faisable (polygone)
            const feasibleRegion = [
                [30, 120], [100, 120], [150, 80], [150, 30], [80, 30], [30, 60]
            ];

            svg.append("polygon")
                .attr("points", feasibleRegion.map(p => p.join(",")).join(" "))
                .attr("fill", "#4ecdc4")
                .attr("opacity", 0.3)
                .attr("stroke", "#4ecdc4")
                .attr("stroke-width", 2);

            // Point optimal
            svg.append("circle")
                .attr("cx", 150)
                .attr("cy", 30)
                .attr("r", 6)
                .attr("fill", "#ff6b6b")
                .attr("stroke", "#fff")
                .attr("stroke-width", 2);

            svg.append("text")
                .attr("x", 160)
                .attr("y", 35)
                .attr("fill", "#333")
                .attr("font-size", "10px")
                .text("Optimal");

            // Axes et labels
            svg.append("line")
                .attr("x1", 30)
                .attr("y1", 120)
                .attr("x2", 270)
                .attr("y2", 120)
                .attr("stroke", "#666")
                .attr("stroke-width", 1);

            svg.append("line")
                .attr("x1", 30)
                .attr("y1", 120)
                .attr("x2", 30)
                .attr("y2", 20)
                .attr("stroke", "#666")
                .attr("stroke-width", 1);
        }

        // Graphiques temps r√©el
        function initRealtimeCharts() {
            // Graphique de volume de transactions
            const volumeSvg = d3.select("#volume-chart");
            volumeSvg.selectAll("*").remove();

            // Gauge d'efficacit√©
            const efficiencySvg = d3.select("#efficiency-gauge");
            efficiencySvg.selectAll("*").remove();

            // Indicateur de stabilit√©
            const stabilitySvg = d3.select("#stability-indicator");
            stabilitySvg.selectAll("*").remove();
        }

        // Mise √† jour des m√©triques temps r√©el
        function startMetricsUpdate() {
            metricsInterval = setInterval(updateMetrics, 2000);
            updateMetrics(); // Mise √† jour initiale
        }

        async function updateMetrics() {
            try {
                // Charger donn√©es r√©elles de simulation si disponible
                const response = await fetch('/api/simulations/current/info');
                if (response.ok) {
                    const data = await response.json();

                    // Utiliser les vraies donn√©es si disponibles
                    const transactionVolume = data.transactions_count || Math.floor(Math.random() * 1000) + 500;
                    const agentsCount = data.agents_count || 0;

                    // Calculer l'efficacit√© Simplex bas√©e sur les vraies donn√©es
                    const simplexEfficiency = agentsCount > 0 ?
                        Math.min(95, Math.floor((transactionVolume / agentsCount) * 10) + 70) :
                        Math.floor(Math.random() * 30) + 70;

                    const activeConstraints = Math.min(10, Math.floor(agentsCount / 10) + 3);
                    const pathsExplored = Math.floor(transactionVolume * 1.5) + 120;
                    const simplexIterations = Math.floor(transactionVolume / 5) + 20;

                    // Mise √† jour des valeurs affich√©es avec vraies donn√©es
                    document.getElementById('transaction-volume').textContent = transactionVolume;
                    document.getElementById('simplex-efficiency').textContent = simplexEfficiency + '%';
                    document.getElementById('active-constraints').textContent = activeConstraints;
                    document.getElementById('paths-explored').textContent = pathsExplored;
                    document.getElementById('simplex-iterations').textContent = simplexIterations;

                    // D√©terminer l'√©tat de stabilit√© bas√© sur vraies m√©triques
                    const stability = simplexEfficiency > 85 ? 'Tr√®s Stable' :
                                    simplexEfficiency > 70 ? 'Stable' : 'Instable';
                    document.getElementById('system-stability').textContent = stability;
                } else {
                    // Fallback vers simulation si API non disponible
                    updateMetricsSimulated();
                }
            } catch (error) {
                console.error('Erreur mise √† jour m√©triques:', error);
                updateMetricsSimulated();
            }
        }

        function updateMetricsSimulated() {
            // Simulation de donn√©es temps r√©el (fallback)
            const transactionVolume = Math.floor(Math.random() * 1000) + 500;
            const simplexEfficiency = Math.floor(Math.random() * 30) + 70;
            const activeConstraints = Math.floor(Math.random() * 5) + 5;
            const pathsExplored = Math.floor(Math.random() * 50) + 120;
            const simplexIterations = Math.floor(Math.random() * 10) + 20;

            document.getElementById('transaction-volume').textContent = transactionVolume;
            document.getElementById('simplex-efficiency').textContent = simplexEfficiency + '%';
            document.getElementById('active-constraints').textContent = activeConstraints;
            document.getElementById('paths-explored').textContent = pathsExplored;
            document.getElementById('simplex-iterations').textContent = simplexIterations;

            const stability = simplexEfficiency > 85 ? 'Tr√®s Stable' :
                            simplexEfficiency > 70 ? 'Stable' : 'Instable';
            document.getElementById('system-stability').textContent = stability;
        }

        // Fonctions pour les boutons de simulation
        function load65AgentsSimulation() {
            // Redirection vers l'interface principale avec chargement de la simulation 65 agents
            fetch('/api/simulations/create-65-agents', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    window.location.href = '/?load65=true';
                } else {
                    alert('Erreur lors du chargement de la simulation 65 agents: ' + data.error);
                }
            })
            .catch(error => {
                console.error('Erreur:', error);
                alert('Erreur de connexion au serveur');
            });
        }

        function openAdvancedMode() {
            // Redirection vers l'interface avec mode avanc√© activ√©
            window.location.href = '/?mode=advanced&caps=true';
        }

        // ===== NOUVELLES FONCTIONS SVG TEMPS R√âEL =====

        // Variables globales pour la simulation interactive
        let simulationState = 'stopped'; // stopped, running, paused
        let simulation65AgentsData = null;
        let svgAnimationIntervals = {};
        let transactionsList = [];

        // Initialisation de la simulation interactive
        async function initializeInteractiveSimulation() {
            setupSimulationControls();
            setupSVGAnimationContainers();

            // Charger les donn√©es initiales
            await loadSimulationInfo();
        }

        // Configuration des contr√¥les de simulation - ENHANCED
        function setupSimulationControls() {
            // Contr√¥les de base
            const startBtn = document.getElementById('start-simulation-btn');
            const pauseBtn = document.getElementById('pause-simulation-btn');
            const stopBtn = document.getElementById('stop-simulation-btn');
            const resetBtn = document.getElementById('reset-simulation-btn');

            startBtn.addEventListener('click', startInteractiveSimulation);
            pauseBtn.addEventListener('click', pauseInteractiveSimulation);
            stopBtn.addEventListener('click', stopInteractiveSimulation);
            resetBtn.addEventListener('click', resetInteractiveSimulation);

            // Contr√¥les manuels avanc√©s
            setupEnhancedControls();
        }

        // Nouveau: Configuration des contr√¥les avanc√©s
        function setupEnhancedControls() {
            // Contr√¥les manuels
            const stepBackBtn = document.getElementById('step-backward-btn');
            const stepForwardBtn = document.getElementById('step-forward-btn');
            const singleStepBtn = document.getElementById('single-step-btn');

            stepBackBtn.addEventListener('click', stepBackward);
            stepForwardBtn.addEventListener('click', stepForward);
            singleStepBtn.addEventListener('click', executeSingleStep);

            // Contr√¥les de vitesse
            const speedSlowBtn = document.getElementById('speed-slow-btn');
            const speedNormalBtn = document.getElementById('speed-normal-btn');
            const speedFastBtn = document.getElementById('speed-fast-btn');
            const speedUltraBtn = document.getElementById('speed-ultra-btn');

            speedSlowBtn.addEventListener('click', () => setAnimationSpeed(4000));
            speedNormalBtn.addEventListener('click', () => setAnimationSpeed(2000));
            speedFastBtn.addEventListener('click', () => setAnimationSpeed(1000));
            speedUltraBtn.addEventListener('click', () => setAnimationSpeed(500));

            // Contr√¥le de saut
            const jumpStepBtn = document.getElementById('jump-step-btn');
            const jumpStepInput = document.getElementById('jump-step-input');

            jumpStepBtn.addEventListener('click', jumpToStep);
            jumpStepInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    jumpToStep();
                }
            });

            // Barre de progression interactive
            const progressContainer = document.querySelector('.progress-container');
            if (progressContainer) {
                progressContainer.addEventListener('click', jumpToProgressPosition);
            }
        }

        // Variables d'animation globales - ENHANCED
        let animationState = {
            active: false,
            currentStep: 0,
            totalSteps: 0,
            interval: null,
            startTime: null,
            errorCount: 0,
            networkErrorCount: 0,
            lastSuccessfulStep: 0,
            isRecovering: false,
            healthCheckInterval: null,
            animationSpeed: 2000, // intervalle en millisecondes
            isPaused: false,
            manualMode: false
        };

        // ===== NOUVELLES FONCTIONS DE CONTR√îLE AVANC√â =====

        // Contr√¥le de vitesse d'animation
        function setAnimationSpeed(speedMs) {
            console.log(`‚öôÔ∏è Changement vitesse animation: ${speedMs}ms`);

            animationState.animationSpeed = speedMs;

            // Mettre √† jour les boutons visuellement
            document.querySelectorAll('.speed-btn').forEach(btn => btn.classList.remove('active'));

            if (speedMs === 4000) document.getElementById('speed-slow-btn').classList.add('active');
            else if (speedMs === 2000) document.getElementById('speed-normal-btn').classList.add('active');
            else if (speedMs === 1000) document.getElementById('speed-fast-btn').classList.add('active');
            else if (speedMs === 500) document.getElementById('speed-ultra-btn').classList.add('active');

            // Red√©marrer l'animation avec la nouvelle vitesse si active
            if (animationState.active && animationState.interval) {
                clearInterval(animationState.interval);
                startStepByStepAnimation();
            }

            updateAnimationStatus(`Vitesse mise √† jour: ${speedMs === 4000 ? 'Lente' : speedMs === 2000 ? 'Normale' : speedMs === 1000 ? 'Rapide' : 'Ultra'}`);
        }

        // √âtape manuelle vers l'arri√®re
        async function stepBackward() {
            if (animationState.currentStep <= 1) {
                console.warn('‚ö†Ô∏è Impossible de reculer: d√©j√† √† la premi√®re √©tape');
                updateAnimationStatus('‚ö†Ô∏è D√©j√† √† la premi√®re √©tape');
                return;
            }

            console.log(`‚è™ √âtape manuelle vers l'arri√®re: ${animationState.currentStep} ‚Üí ${animationState.currentStep - 1}`);

            // Simuler le retour (pour l'instant, juste mettre √† jour l'affichage)
            animationState.currentStep--;
            updateProgressDisplay();
            updateAnimationStatus(`‚è™ Retour √† l'√©tape ${animationState.currentStep}`);
        }

        // √âtape manuelle vers l'avant
        async function stepForward() {
            if (animationState.currentStep >= animationState.totalSteps) {
                console.warn('‚ö†Ô∏è Impossible d\'avancer: derni√®re √©tape atteinte');
                updateAnimationStatus('‚ö†Ô∏è Derni√®re √©tape atteinte');
                return;
            }

            console.log(`‚è© √âtape manuelle vers l'avant: ${animationState.currentStep} ‚Üí ${animationState.currentStep + 1}`);

            // Ex√©cuter la prochaine √©tape
            await executeNextAnimationStep();
        }

        // Ex√©cution d'une seule √©tape
        async function executeSingleStep() {
            console.log('‚èØÔ∏è Ex√©cution d\'une seule √©tape');

            if (animationState.active) {
                // Mettre en pause temporairement
                const wasActive = animationState.active;
                animationState.active = false;
                clearInterval(animationState.interval);
                animationState.interval = null;

                // Ex√©cuter une √©tape
                await executeNextAnimationStep();

                updateAnimationStatus('‚èØÔ∏è √âtape unique ex√©cut√©e');
            } else {
                // Animation arr√™t√©e, ex√©cuter juste une √©tape
                await executeNextAnimationStep();
            }
        }

        // Saut vers une √©tape sp√©cifique
        async function jumpToStep() {
            const jumpInput = document.getElementById('jump-step-input');
            const targetStep = parseInt(jumpInput.value);

            if (isNaN(targetStep) || targetStep < 1 || targetStep > animationState.totalSteps) {
                alert(`Veuillez entrer un num√©ro d'√©tape valide (1-${animationState.totalSteps})`);
                return;
            }

            console.log(`üéØ Saut vers l'√©tape ${targetStep}`);

            // Pour l'instant, simuler le saut en mettant √† jour l'affichage
            // Dans une impl√©mentation compl√®te, il faudrait appeler l'API pour synchroniser
            animationState.currentStep = targetStep;
            updateProgressDisplay();
            updateAnimationStatus(`üéØ Saut vers l'√©tape ${targetStep}`);

            jumpInput.value = '';
        }

        // Saut vers position dans la barre de progression
        function jumpToProgressPosition(event) {
            if (animationState.totalSteps === 0) return;

            const progressBar = event.currentTarget.querySelector('.progress-bar');
            const rect = progressBar.getBoundingClientRect();
            const clickX = event.clientX - rect.left;
            const progressPercent = (clickX / rect.width) * 100;
            const targetStep = Math.ceil((progressPercent / 100) * animationState.totalSteps);

            if (targetStep >= 1 && targetStep <= animationState.totalSteps) {
                console.log(`üéØ Clic barre progression: ${progressPercent.toFixed(1)}% ‚Üí √©tape ${targetStep}`);

                animationState.currentStep = targetStep;
                updateProgressDisplay();
                updateAnimationStatus(`üéØ Navigation vers √©tape ${targetStep}`);
            }
        }

        // Mise √† jour de l'affichage de progression
        function updateProgressDisplay() {
            const progressPercent = animationState.totalSteps > 0 ?
                (animationState.currentStep / animationState.totalSteps) * 100 : 0;

            const progressElement = document.querySelector('.transaction-progress');
            if (progressElement) {
                progressElement.style.width = progressPercent + '%';
            }

            // Mettre √† jour le compteur de transactions
            const transactionCounter = document.getElementById('total-transactions-count');
            if (transactionCounter) {
                transactionCounter.textContent = `${animationState.currentStep}/${animationState.totalSteps}`;
            }
        }

        // Mise √† jour de l'√©tat des boutons selon le contexte
        function updateControlButtonsState() {
            const isActive = animationState.active;
            const hasSteps = animationState.totalSteps > 0;
            const canGoBack = animationState.currentStep > 1;
            const canGoForward = animationState.currentStep < animationState.totalSteps;

            // Boutons manuels
            document.getElementById('step-backward-btn').disabled = !hasSteps || !canGoBack;
            document.getElementById('step-forward-btn').disabled = !hasSteps || !canGoForward;
            document.getElementById('single-step-btn').disabled = !hasSteps || !canGoForward;

            // Contr√¥le de saut
            document.getElementById('jump-step-btn').disabled = !hasSteps;
            document.getElementById('jump-step-input').disabled = !hasSteps;

            // Mettre √† jour le placeholder de l'input
            const jumpInput = document.getElementById('jump-step-input');
            if (jumpInput && hasSteps) {
                jumpInput.setAttribute('max', animationState.totalSteps);
                jumpInput.placeholder = `1-${animationState.totalSteps}`;
            }
        }

        // Nouveau: Validation de l'√©tat d'animation
        function validateAnimationState() {
            const issues = [];

            // V√©rifications de coh√©rence
            if (animationState.currentStep > animationState.totalSteps) {
                issues.push('currentStep > totalSteps');
            }

            if (animationState.active && !animationState.interval) {
                issues.push('Animation active mais pas de timer');
            }

            if (!animationState.active && animationState.interval) {
                issues.push('Timer actif mais animation inactive');
            }

            if (animationState.errorCount > 10) {
                issues.push('Trop d\'erreurs accumul√©es');
            }

            if (issues.length > 0) {
                console.warn('‚ö†Ô∏è INCOH√âRENCES D\'ANIMATION D√âTECT√âES:', issues);
                return false;
            }

            return true;
        }

        // Nouveau: R√©cup√©ration d'√©tat d'animation
        async function recoverAnimationState() {
            if (animationState.isRecovering) {
                console.log('üîÑ R√©cup√©ration d√©j√† en cours...');
                return;
            }

            animationState.isRecovering = true;
            console.log('üöë D√âBUT R√âCUP√âRATION D\'ANIMATION');

            try {
                // Nettoyer l'√©tat actuel
                if (animationState.interval) {
                    clearInterval(animationState.interval);
                    animationState.interval = null;
                }

                // V√©rifier l'√©tat du serveur
                const statusResponse = await fetch('/api/simulations/animate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ action: 'status' })
                });

                if (statusResponse.ok) {
                    const statusData = await statusResponse.json();

                    // Synchroniser avec l'√©tat du serveur
                    animationState.currentStep = statusData.current_step || 0;
                    animationState.totalSteps = statusData.total_transactions || 33;

                    console.log(`üîÑ √âtat synchronis√©: ${animationState.currentStep}/${animationState.totalSteps}`);

                    // Reprendre l'animation si elle √©tait active
                    if (statusData.active && animationState.currentStep < animationState.totalSteps) {
                        console.log('üöÄ Reprise automatique de l\'animation');
                        animationState.active = true;
                        await startStepByStepAnimation();
                    }
                } else {
                    console.error('‚ùå Impossible de r√©cup√©rer l\'status du serveur');
                }
            } catch (error) {
                console.error('‚ùå Erreur lors de la r√©cup√©ration:', error);
            } finally {
                animationState.isRecovering = false;
            }
        }

        // Nouveau: Health check p√©riodique
        function startAnimationHealthCheck() {
            if (animationState.healthCheckInterval) {
                clearInterval(animationState.healthCheckInterval);
            }

            animationState.healthCheckInterval = setInterval(() => {
                if (animationState.active) {
                    const isValid = validateAnimationState();
                    if (!isValid) {
                        console.warn('üöë Incoh√©rence d√©tect√©e, tentative de r√©cup√©ration...');
                        recoverAnimationState();
                    }
                }
            }, 10000); // V√©rification toutes les 10 secondes
        }

        // Nouveau: Arr√™ter health check
        function stopAnimationHealthCheck() {
            if (animationState.healthCheckInterval) {
                clearInterval(animationState.healthCheckInterval);
                animationState.healthCheckInterval = null;
            }
        }

        // D√©marrer la simulation interactive - ENHANCED ROBUSTNESS
        async function startInteractiveSimulation() {
            try {
                console.log('üöÄ D√âMARRAGE SIMULATION INTERACTIVE');
                updateSimulationState('running');

                // D√©marrer le health check
                startAnimationHealthCheck();

                // √âtape 1: Cr√©er la simulation 65 agents si n√©cessaire
                if (!simulation65AgentsData) {
                    console.log('üîç Cr√©ation simulation 65 agents...');
                    await create65AgentsSimulation();
                }

                // √âtape 2: Initialiser l'animation step-by-step
                console.log('‚öôÔ∏è Initialisation animation...');
                await initializeStepAnimation();

                // √âtape 3: D√©marrer les animations SVG temps r√©el
                console.log('üé® D√©marrage animations SVG...');
                startSVGAnimations();

                // √âtape 4: D√©marrer les m√©triques temps r√©el
                console.log('üìà D√©marrage m√©triques...');
                startRealTimeMetrics();

                // √âtape 5: D√©marrer animation continue
                console.log('üé¨ D√©marrage animation continue...');
                await startStepByStepAnimation();

                console.log('‚úÖ SIMULATION D√âMARR√âE AVEC SUCC√àS');

            } catch (error) {
                console.error('‚ùå ERREUR D√âMARRAGE SIMULATION:', error);
                updateSimulationState('error');

                // Nettoyage en cas d'erreur
                stopAnimationHealthCheck();
                if (animationState.interval) {
                    clearInterval(animationState.interval);
                    animationState.interval = null;
                }

                // Affichage d'erreur d√©taill√©
                const errorMessage = error.message || 'Erreur inconnue';
                updateAnimationStatus(`‚ùå Erreur: ${errorMessage}`);

                // Proposition de r√©cup√©ration
                if (confirm(`Erreur lors du d√©marrage: ${errorMessage}\n\nVoulez-vous essayer de r√©cup√©rer automatiquement?`)) {
                    setTimeout(() => {
                        recoverAnimationState();
                    }, 2000);
                }
            }
        }

        // Initialiser l'animation step-by-step - ENHANCED ROBUSTNESS
        async function initializeStepAnimation(retryCount = 0) {
            const maxRetries = 3;
            const timeoutMs = 8000;

            try {
                console.log(`üîÑ Initialisation animation (tentative ${retryCount + 1}/${maxRetries + 1})`);

                // Controller pour timeout
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), timeoutMs);

                const response = await fetch('/api/simulations/animate', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ action: 'reset' }),
                    signal: controller.signal
                });

                clearTimeout(timeoutId);

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                if (data.success) {
                    animationState.totalSteps = data.total_transactions;
                    animationState.currentStep = 0;
                    animationState.lastSuccessfulStep = 0;

                    console.log(`‚úÖ Animation initialis√©e: ${data.total_transactions} transactions pr√™tes`);
                    return data;
                } else {
                    throw new Error(data.error || '√âchec initialisation animation');
                }
            } catch (error) {
                console.warn(`‚ö†Ô∏è Erreur initialisation (tentative ${retryCount + 1}):`, error.message);

                if (retryCount < maxRetries) {
                    const delayMs = Math.pow(2, retryCount) * 1000;
                    console.log(`üîÑ Retry dans ${delayMs}ms...`);

                    await new Promise(resolve => setTimeout(resolve, delayMs));
                    return initializeStepAnimation(retryCount + 1);
                } else {
                    console.error('üö´ √âchec d√©finitif initialisation animation');
                    throw new Error(`√âchec apr√®s ${maxRetries + 1} tentatives: ${error.message}`);
                }
            }
        }

        // D√©marrer animation step-by-step automatique - ENHANCED
        async function startStepByStepAnimation() {
            console.log('üöÄ D√âBUT startStepByStepAnimation()');

            // Nettoyer tout interval existant
            if (animationState.interval) {
                console.log('üßπ Nettoyage interval existant');
                clearInterval(animationState.interval);
                animationState.interval = null;
            }

            // R√©initialiser compteurs d'erreurs et horodatage
            animationState.errorCount = 0;
            animationState.networkErrorCount = 0;
            animationState.active = true;
            animationState.startTime = Date.now(); // Pour calculs de performance

            console.log(`üé¨ D√©marrage animation avec ${animationState.totalSteps} transactions √† traiter`);
            updateAnimationStatus(`D√©marrage animation - ${animationState.totalSteps} transactions`);

            // Affichage m√©trique initiale
            console.log('üìà M√âTRIQUES ANIMATION D√âMARR√âE:');
            console.log(`   ‚îî‚îÄ Transactions totales: ${animationState.totalSteps}`);
            console.log(`   ‚îî‚îÄ Intervalle: 2000ms par transaction`);
            console.log(`   ‚îî‚îÄ Dur√©e estim√©e: ${(animationState.totalSteps * 2)} secondes`);
            console.log(`   ‚îî‚îÄ Horodatage d√©but: ${new Date().toISOString()}`);

            // Initialiser interface de suivi
            initializeProgressTracking();

            // Lancer le timer d'animation
            animationState.interval = setInterval(async () => {
                if (animationState.active) {
                    await executeNextAnimationStep();
                } else {
                    console.log('‚èπÔ∏è Animation marqu√©e inactive, arr√™t du timer');
                    clearInterval(animationState.interval);
                    animationState.interval = null;
                }
            }, animationState.animationSpeed); // Vitesse configurable

            console.log(`‚úÖ Timer animation d√©marr√© - interval ID: ${animationState.interval}`);

            // D√©marrer le monitoring de sant√© si pas d√©j√† actif
            if (!animationState.healthCheckInterval) {
                startAnimationHealthCheck();
            }

            // Mettre √† jour l'√©tat des boutons de contr√¥le
            updateControlButtonsState();
        }

        // Nouveau: Initialiser le suivi de progression
        function initializeProgressTracking() {
            // R√©initialiser la barre de progression
            const progressElement = document.querySelector('.transaction-progress');
            if (progressElement) {
                progressElement.style.width = '0%';
                progressElement.style.transition = 'width 0.8s ease-in-out';
            }

            // Afficher message d'initialisation
            const transactionDisplay = document.querySelector('#current-transaction-display');
            if (transactionDisplay) {
                transactionDisplay.innerHTML = `
                    <div class="initialization-display">
                        <div class="loading-spinner"></div>
                        <div style="margin-left: 10px;">
                            <strong>üöÄ Initialisation de l'animation...</strong><br>
                            <span style="color: #666; font-size: 0.9em;">
                                Pr√©paration de ${animationState.totalSteps} transactions
                            </span>
                        </div>
                    </div>
                `;
            }

            // Commencer le clignotement du statut
            startStatusBlink();
        }

        // Nouveau: Animation de clignotement pour indiquer l'activit√©
        function startStatusBlink() {
            const stateElement = document.getElementById('simulation-state');
            if (stateElement) {
                stateElement.style.animation = 'pulse 2s infinite';
            }
        }

        // Ex√©cuter la prochaine √©tape d'animation
        async function executeNextAnimationStep() {
            console.log(`üîÑ DEBUT √©tape animation - √âtat actuel: active=${animationState.active}, step=${animationState.currentStep}/${animationState.totalSteps}`);

            if (!animationState.active) {
                console.log('‚è∏Ô∏è Animation inactive, skipping step');
                return;
            }

            try {
                const response = await fetch('/api/simulations/animate', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ action: 'step' })
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                console.log('üì° API Response:', data);

                if (data.success) {
                    if (data.completed) {
                        // Animation termin√©e
                        console.log('üé¨ ANIMATION TERMIN√âE: toutes les transactions ex√©cut√©es');
                        animationState.active = false;
                        clearInterval(animationState.interval);
                        animationState.interval = null;
                        updateSimulationState('completed');
                        showAnimationComplete();
                    } else {
                        // Mise √† jour interface avec la nouvelle transaction
                        animationState.currentStep = data.step;
                        updateTransactionProgress(data);

                        // Mettre √† jour le statut des transactions
                        try {
                            const currentStatus = await getCurrentSimulationInfo();
                            updateSimulationStatus(currentStatus);
                        } catch (statusError) {
                            console.warn('‚ö†Ô∏è Erreur mise √† jour status (non-critique):', statusError);
                        }

                        console.log(`‚úÖ Transaction ${data.step}/${data.total_steps} R√âUSSIE: ${data.transaction.source} ‚Üí ${data.transaction.target} (${data.transaction.amount})`);
                        console.log(`üìä Progression: ${data.progress_percent.toFixed(1)}%`);

                        // Feedback visuel renforc√©
                        updateAnimationStatus(`Transaction ${data.step}/${data.total_steps} en cours...`);
                    }
                } else {
                    console.error('‚ùå Erreur API √©tape animation:', data.error);

                    // NE PAS arr√™ter l'animation pour une erreur ponctuelle
                    // Incr√©menter un compteur d'erreurs et continuer
                    animationState.errorCount = (animationState.errorCount || 0) + 1;

                    if (animationState.errorCount >= 3) {
                        console.error('üõë Trop d\'erreurs cons√©cutives, arr√™t animation');
                        stopAnimationWithError('Trop d\'erreurs cons√©cutives');
                    } else {
                        console.warn(`‚ö†Ô∏è Erreur ${animationState.errorCount}/3, continuer animation...`);
                        updateAnimationStatus(`Erreur transaction ${animationState.currentStep}, retry...`);
                    }
                }
            } catch (error) {
                console.error('üö® EXCEPTION ex√©cution √©tape:', error);

                // Gestion d'erreur robuste - ne pas arr√™ter imm√©diatement
                animationState.networkErrorCount = (animationState.networkErrorCount || 0) + 1;

                if (animationState.networkErrorCount >= 5) {
                    console.error('üõë Trop d\'erreurs r√©seau, arr√™t animation');
                    stopAnimationWithError('Erreurs r√©seau r√©p√©t√©es');
                } else {
                    console.warn(`‚ö†Ô∏è Erreur r√©seau ${animationState.networkErrorCount}/5, retry dans 3 secondes...`);
                    updateAnimationStatus(`Erreur r√©seau, retry ${animationState.networkErrorCount}/5...`);
                }
            }
        }

        // Arr√™ter animation avec message d'erreur - ENHANCED
        function stopAnimationWithError(message) {
            console.error('üõë ARR√äT D\'ANIMATION AVEC ERREUR:', message);

            animationState.active = false;
            if (animationState.interval) {
                clearInterval(animationState.interval);
                animationState.interval = null;
            }

            // Arr√™ter le health check
            stopAnimationHealthCheck();

            updateSimulationState('error');
            updateAnimationStatus(`‚ùå Animation arr√™t√©e: ${message}`);

            // Proposition de r√©cup√©ration automatique
            const errorContainer = document.querySelector('#current-transaction-display');
            if (errorContainer) {
                errorContainer.innerHTML = `
                    <div class="error-recovery-display">
                        <div style="color: #dc3545; font-size: 1.2em; margin-bottom: 10px;">
                            ‚ùå Animation Arr√™t√©e
                        </div>
                        <div style="color: #6c757d; margin-bottom: 15px;">
                            ${message}
                        </div>
                        <button onclick="recoverAnimationState()" class="control-btn start-btn" style="font-size: 0.9em;">
                            üöë Tentative de R√©cup√©ration
                        </button>
                    </div>
                `;
            }

            // Log d√©taill√© pour debugging
            console.error('üìà √âTAT AU MOMENT DE L\'ERREUR:', {
                currentStep: animationState.currentStep,
                totalSteps: animationState.totalSteps,
                errorCount: animationState.errorCount,
                networkErrorCount: animationState.networkErrorCount,
                lastSuccessfulStep: animationState.lastSuccessfulStep
            });
        }

        // Affichage fin animation - ENHANCED
        function showAnimationComplete() {
            updateAnimationStatus('üéâ Animation termin√©e avec succ√®s!');
            console.log('üéâ ANIMATION COMPL√àTE - Toutes les transactions ex√©cut√©es');

            // Calcul du temps total √©coul√©
            const totalTime = (Date.now() - animationState.startTime) / 1000;
            console.log(`üìà STATISTIQUES FINALES:`);
            console.log(`   ‚îî‚îÄ Dur√©e totale: ${totalTime.toFixed(1)}s`);
            console.log(`   ‚îî‚îÄ Transactions trait√©es: ${animationState.totalSteps}`);
            console.log(`   ‚îî‚îÄ Vitesse moyenne: ${(animationState.totalSteps / totalTime * 60).toFixed(1)} tx/min`);

            // Affichage de completion dans l'interface
            const transactionDisplay = document.querySelector('#current-transaction-display');
            if (transactionDisplay) {
                transactionDisplay.innerHTML = `
                    <div class="completion-display">
                        <div class="completion-icon">üéâ</div>
                        <div class="completion-text">
                            <strong style="color: #28a745;">Animation Termin√©e avec Succ√®s!</strong><br>
                            <span style="color: #6c757d; font-size: 0.9em;">
                                ${animationState.totalSteps} transactions trait√©es en ${totalTime.toFixed(1)}s
                            </span><br>
                            <span style="color: #4ecdc4; font-size: 0.8em;">
                                Vitesse: ${(animationState.totalSteps / totalTime * 60).toFixed(1)} transactions/minute
                            </span>
                        </div>
                    </div>
                `;
            }

            // Animation de celebration pour la barre de progression
            const progressElement = document.querySelector('.transaction-progress');
            if (progressElement) {
                progressElement.style.background = 'linear-gradient(45deg, #28a745, #20c997)';
                progressElement.style.boxShadow = '0 0 25px rgba(40, 167, 69, 0.8)';
            }

            // Arr√™ter le clignotement du statut
            stopStatusBlink();

            // Mettre √† jour l'√©tat des boutons
            updateControlButtonsState();
        }

        // Nouveau: Arr√™ter l'animation de clignotement
        function stopStatusBlink() {
            const stateElement = document.getElementById('simulation-state');
            if (stateElement) {
                stateElement.style.animation = 'none';
            }
        }

        // Mise √† jour status animation en temps r√©el - ENHANCED
        function updateAnimationStatus(message) {
            const progressText = document.getElementById('animation-progress-text');
            if (progressText) {
                progressText.textContent = message;

                // Animation flash pour indiquer mise √† jour
                progressText.style.background = 'rgba(78, 205, 196, 0.3)';
                setTimeout(() => {
                    progressText.style.background = 'transparent';
                }, 500);
            }

            // Mise √† jour du badge d'√©tat dans la barre de titre
            updateSimulationStateBadge(message);

            // Affichage console temps r√©el pour debugging
            console.log('üìä STATUS UPDATE:', message);
        }

        // Nouveau: Badge d'√©tat en temps r√©el
        function updateSimulationStateBadge(message) {
            const stateElement = document.getElementById('simulation-state');
            if (stateElement) {
                if (message.includes('Transaction')) {
                    stateElement.textContent = 'üîÑ En cours';
                    stateElement.style.color = '#4ecdc4';
                } else if (message.includes('termin√©e') || message.includes('succ√®s')) {
                    stateElement.textContent = '‚úÖ Termin√©e';
                    stateElement.style.color = '#28a745';
                } else if (message.includes('Erreur') || message.includes('‚ùå')) {
                    stateElement.textContent = '‚ùå Erreur';
                    stateElement.style.color = '#dc3545';
                } else if (message.includes('D√©marrage')) {
                    stateElement.textContent = 'üöÄ D√©marrage';
                    stateElement.style.color = '#ffc107';
                }
            }
        }

        // Mettre √† jour la progression des transactions - ENHANCED
        function updateTransactionProgress(data) {
            // Animation progressive de la barre de progression
            const progressElement = document.querySelector('.transaction-progress');
            if (progressElement) {
                // Animation fluide de la progression
                progressElement.style.transition = 'width 0.8s ease-in-out';
                progressElement.style.width = data.progress_percent + '%';

                // Effet pulse lors de la mise √† jour
                progressElement.style.boxShadow = '0 0 20px rgba(78, 205, 196, 0.8)';
                setTimeout(() => {
                    progressElement.style.boxShadow = 'none';
                }, 800);
            }

            // Affichage enrichi de la transaction courante
            const transactionDisplay = document.querySelector('#current-transaction-display');
            if (transactionDisplay) {
                transactionDisplay.innerHTML = `
                    <div class="transaction-current-display">
                        <div class="transaction-header">
                            <span class="live-indicator"></span>
                            <strong style="color: #4ecdc4;">Transaction ${data.step}/${data.total_steps}</strong>
                            <span class="transaction-progress-percent">${data.progress_percent.toFixed(1)}%</span>
                        </div>
                        <div class="transaction-flow">
                            <span class="source-agent">${data.transaction.source}</span>
                            <span class="arrow">‚Üí</span>
                            <span class="target-agent">${data.transaction.target}</span>
                        </div>
                        <div class="transaction-details">
                            <span class="amount">üí∞ ${data.transaction.amount}</span>
                            <span class="flow-type">(${data.transaction.flow})</span>
                        </div>
                        <div class="transaction-timing">
                            ‚è±Ô∏è √âtape ${data.step} ‚Ä¢ Restant: ${data.total_steps - data.step}
                        </div>
                    </div>
                `;

                // Animation d'entr√©e pour la nouvelle transaction
                transactionDisplay.style.transform = 'scale(0.95)';
                transactionDisplay.style.opacity = '0.7';
                setTimeout(() => {
                    transactionDisplay.style.transform = 'scale(1)';
                    transactionDisplay.style.opacity = '1';
                }, 200);
            }

            // Mise √† jour des compteurs en temps r√©el
            updateRealTimeCounters(data);
        }

        // Nouveau: Mise √† jour des compteurs temps r√©el
        function updateRealTimeCounters(data) {
            // Mise √† jour du compteur de transactions
            const transactionCounter = document.getElementById('total-transactions-count');
            if (transactionCounter) {
                transactionCounter.textContent = `${data.step}/${data.total_steps}`;

                // Animation du compteur
                transactionCounter.style.transform = 'scale(1.1)';
                transactionCounter.style.color = '#4ecdc4';
                setTimeout(() => {
                    transactionCounter.style.transform = 'scale(1)';
                    transactionCounter.style.color = 'inherit';
                }, 300);
            }

            // Mise √† jour de m√©triques additionnelles
            updateTransactionMetrics(data);

            // Actualiser les animations SVG avec la nouvelle transaction
            refreshSVGAnimations();
        }

        // Nouveau: M√©triques d√©taill√©es de transaction
        function updateTransactionMetrics(data) {
            // Calculer vitesse de traitement
            const processingSpeed = (data.step / (Date.now() - animationState.startTime || 1)) * 1000 * 60; // transactions par minute

            // Temps estim√© restant
            const remainingTransactions = data.total_steps - data.step;
            const estimatedTimeRemaining = remainingTransactions * 2; // 2 secondes par transaction

            // Afficher dans la console pour monitoring
            console.log(`üìà M√âTRIQUES TEMPS R√âEL:`);
            console.log(`   ‚îî‚îÄ Progression: ${data.progress_percent.toFixed(1)}%`);
            console.log(`   ‚îî‚îÄ Transaction: ${data.step}/${data.total_steps}`);
            console.log(`   ‚îî‚îÄ Restant: ${remainingTransactions} transactions`);
            console.log(`   ‚îî‚îÄ Temps estim√©: ${estimatedTimeRemaining}s`);
            console.log(`   ‚îî‚îÄ Flux: ${data.transaction.flow}`);
            console.log(`   ‚îî‚îÄ Montant: ${data.transaction.amount}`);
        }

        // Cr√©er la simulation 65 agents - ENHANCED ROBUSTNESS
        async function create65AgentsSimulation(retryCount = 0) {
            const maxRetries = 3;
            const timeoutMs = 10000; // 10 secondes timeout

            try {
                console.log(`üì° Tentative ${retryCount + 1}/${maxRetries + 1} - Cr√©ation simulation 65 agents`);

                // Controller pour timeout
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), timeoutMs);

                const response = await fetch('/api/simulations/create-65-agents', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    signal: controller.signal
                });

                clearTimeout(timeoutId);

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                if (data.success) {
                    simulation65AgentsData = data;
                    updateSimulationStatus(data);
                    console.log('‚úÖ Simulation 65 agents cr√©√©e avec succ√®s');
                    return data;
                } else {
                    throw new Error(data.error || '√âchec cr√©ation simulation 65 agents');
                }
            } catch (error) {
                console.warn(`‚ö†Ô∏è Erreur tentative ${retryCount + 1}:`, error.message);

                if (retryCount < maxRetries) {
                    const delayMs = Math.pow(2, retryCount) * 1000; // Backoff exponentiel
                    console.log(`üîÑ Retry dans ${delayMs}ms...`);

                    await new Promise(resolve => setTimeout(resolve, delayMs));
                    return create65AgentsSimulation(retryCount + 1);
                } else {
                    console.error('üö´ √âchec d√©finitif cr√©ation simulation 65 agents');
                    throw new Error(`√âchec apr√®s ${maxRetries + 1} tentatives: ${error.message}`);
                }
            }
        }

        // D√©marrer les animations SVG temps r√©el
        function startSVGAnimations() {
            // R√©cup√©rer l'√©tape courante
            const currentStep = animationState.currentStep || 1;

            // Animation √©conomie compl√®te
            loadSVGAnimation('economy-animation-svg', `/api/svg/economy_animation?current_step=${currentStep}`);

            // Dashboard performance
            loadSVGAnimation('performance-dashboard-svg', `/api/svg/performance_dashboard?current_step=${currentStep}`);

            // √âtapes Simplex
            loadSVGAnimation('simplex-steps-svg', `/api/svg/simplex_steps?current_step=${currentStep}`);

            // Actualiser les animations toutes les 3 secondes
            svgAnimationIntervals.refresh = setInterval(() => {
                if (simulationState === 'running') {
                    refreshSVGAnimations();
                }
            }, 3000);
        }

        // Charger une animation SVG depuis l'API - ENHANCED ROBUSTNESS
        async function loadSVGAnimation(containerId, endpoint, retryCount = 0) {
            const maxRetries = 2;
            const timeoutMs = 5000; // 5 secondes timeout pour SVG

            try {
                // Validation des param√®tres
                const container = document.getElementById(containerId);
                if (!container) {
                    console.error(`‚ùå Container SVG introuvable: ${containerId}`);
                    return;
                }

                // Controller pour timeout
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), timeoutMs);

                const response = await fetch(endpoint, {
                    signal: controller.signal,
                    headers: {
                        'Accept': 'image/svg+xml, text/plain'
                    }
                });

                clearTimeout(timeoutId);

                if (response.ok) {
                    const svgContent = await response.text();

                    // Validation du contenu SVG
                    if (svgContent.trim().length === 0) {
                        throw new Error('Contenu SVG vide');
                    }

                    container.innerHTML = svgContent;
                    console.log(`‚úÖ SVG charg√©: ${endpoint}`);
                } else if (response.status === 404) {
                    // API pas encore impl√©ment√©e - pas une erreur critique
                    container.innerHTML = `
                        <div style="color: #666; text-align: center; padding: 30px; background: rgba(255,255,255,0.05); border-radius: 8px;">
                            <div style="font-size: 2em; margin-bottom: 10px;">üõ†Ô∏è</div>
                            <div>API SVG en d√©veloppement</div>
                            <div style="font-size: 0.8em; margin-top: 5px; color: #999;">${endpoint}</div>
                        </div>
                    `;
                } else {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
            } catch (error) {
                console.warn(`‚ö†Ô∏è Erreur SVG ${endpoint} (tentative ${retryCount + 1}):`, error.message);

                const container = document.getElementById(containerId);
                if (!container) return;

                if (retryCount < maxRetries && !error.name === 'AbortError') {
                    // Retry pour erreurs non-timeout
                    const delayMs = (retryCount + 1) * 1000;
                    console.log(`üîÑ Retry SVG dans ${delayMs}ms...`);

                    setTimeout(() => {
                        loadSVGAnimation(containerId, endpoint, retryCount + 1);
                    }, delayMs);
                } else {
                    // Affichage d'erreur final
                    container.innerHTML = `
                        <div style="color: #dc3545; text-align: center; padding: 30px; background: rgba(220,53,69,0.1); border-radius: 8px; border: 1px solid rgba(220,53,69,0.3);">
                            <div style="font-size: 2em; margin-bottom: 10px;">‚ö†Ô∏è</div>
                            <div>Animation non disponible</div>
                            <div style="font-size: 0.8em; margin-top: 5px; color: #999;">Erreur: ${error.message}</div>
                        </div>
                    `;
                }
            }
        }

        // Actualiser toutes les animations SVG
        function refreshSVGAnimations() {
            // R√©cup√©rer l'√©tape courante
            const currentStep = animationState.currentStep || 1;

            loadSVGAnimation('economy-animation-svg', `/api/svg/economy_animation?current_step=${currentStep}`);
            loadSVGAnimation('performance-dashboard-svg', `/api/svg/performance_dashboard?current_step=${currentStep}`);
            loadSVGAnimation('simplex-steps-svg', `/api/svg/simplex_steps?current_step=${currentStep}`);

            // Charger la liste des transactions pour le s√©lecteur
            loadTransactionsList();
        }

        // Charger la liste des transactions
        async function loadTransactionsList() {
            try {
                const response = await fetch('/api/transactions/3d');
                if (response.ok) {
                    const data = await response.json();
                    transactionsList = data.transactions || [];
                    updateTransactionSelector();
                }
            } catch (error) {
                console.error('Erreur chargement transactions:', error);
            }
        }

        // Mettre √† jour le s√©lecteur de transactions
        function updateTransactionSelector() {
            const selector = document.getElementById('transaction-selector');
            selector.innerHTML = '<option value="">S√©lectionner transaction...</option>';

            transactionsList.slice(0, 10).forEach(tx => {
                const option = document.createElement('option');
                option.value = tx.transaction_id;
                option.textContent = `${tx.source_account_id} ‚Üí ${tx.target_account_id} (${tx.amount})`;
                selector.appendChild(option);
            });

            // Gestionnaire de changement
            selector.addEventListener('change', (e) => {
                if (e.target.value) {
                    loadTransactionDetail(e.target.value);
                }
            });
        }

        // Charger le d√©tail d'une transaction
        async function loadTransactionDetail(txId) {
            loadSVGAnimation('transaction-detail-svg', `/api/svg/transaction/${txId}`);
        }

        // D√©marrer les m√©triques temps r√©el connect√©es
        function startRealTimeMetrics() {
            svgAnimationIntervals.metrics = setInterval(updateRealTimeMetrics, 2000);
            updateRealTimeMetrics(); // Mise √† jour initiale
        }

        // Mettre √† jour les m√©triques temps r√©el
        async function updateRealTimeMetrics() {
            try {
                // Charger les informations de simulation
                const response = await fetch('/api/simulations/current/info');
                if (response.ok) {
                    const data = await response.json();

                    // Mettre √† jour les m√©triques affich√©es
                    document.getElementById('transaction-volume').textContent = data.transactions_count || 0;
                    document.getElementById('simplex-efficiency').textContent =
                        Math.floor(Math.random() * 30 + 70) + '%'; // Simulation pour maintenant

                    // Mettre √† jour les compteurs de statut
                    document.getElementById('active-agents-count').textContent = data.agents_count || 0;
                    document.getElementById('total-transactions-count').textContent = data.transactions_count || 0;
                }
            } catch (error) {
                console.error('Erreur mise √† jour m√©triques:', error);
            }
        }

        // Charger les informations de simulation
        async function loadSimulationInfo() {
            try {
                const response = await fetch('/api/simulations/current/info');
                if (response.ok) {
                    const data = await response.json();
                    if (data.agents_count > 0) {
                        simulation65AgentsData = data;
                        updateSimulationStatus(data);
                    }
                }
            } catch (error) {
                console.error('Erreur chargement info simulation:', error);
            }
        }

        // Mettre √† jour l'√©tat de la simulation
        function updateSimulationState(newState) {
            simulationState = newState;

            const startBtn = document.getElementById('start-simulation-btn');
            const pauseBtn = document.getElementById('pause-simulation-btn');
            const stopBtn = document.getElementById('stop-simulation-btn');
            const stateDisplay = document.getElementById('simulation-state');

            // Mise √† jour des boutons
            switch (newState) {
                case 'running':
                    startBtn.disabled = true;
                    pauseBtn.disabled = false;
                    stopBtn.disabled = false;
                    stateDisplay.textContent = 'En cours';
                    stateDisplay.style.color = '#28a745';
                    break;
                case 'paused':
                    startBtn.disabled = false;
                    pauseBtn.disabled = true;
                    stopBtn.disabled = false;
                    stateDisplay.textContent = 'En pause';
                    stateDisplay.style.color = '#ffc107';
                    break;
                case 'stopped':
                    startBtn.disabled = false;
                    pauseBtn.disabled = true;
                    stopBtn.disabled = true;
                    stateDisplay.textContent = 'Arr√™t√©e';
                    stateDisplay.style.color = '#6c757d';
                    break;
            }
        }

        // Mettre √† jour le statut de la simulation
        function updateSimulationStatus(data) {
            document.getElementById('active-agents-count').textContent = data.agents_count || 0;
            document.getElementById('total-transactions-count').textContent = data.transactions_count || 0;
        }

        // Pause simulation
        function pauseInteractiveSimulation() {
            updateSimulationState('paused');
            animationState.active = false;
            if (animationState.interval) {
                clearInterval(animationState.interval);
            }
            stopSVGAnimations();
        }

        // Arr√™ter simulation
        function stopInteractiveSimulation() {
            updateSimulationState('stopped');
            animationState.active = false;
            if (animationState.interval) {
                clearInterval(animationState.interval);
            }
            stopSVGAnimations();
            clearSVGContainers();
        }

        // Reset simulation
        async function resetInteractiveSimulation() {
            stopInteractiveSimulation();
            animationState = {
                active: false,
                currentStep: 0,
                totalSteps: 0,
                interval: null
            };

            // Reset animation backend
            try {
                await fetch('/api/simulations/animate', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ action: 'reset' })
                });
            } catch (error) {
                console.log('Note: Reset animation backend √©chou√© (normal si pas de simulation active)');
            }

            simulation65AgentsData = null;
            updateSimulationStatus({ agents_count: 0, transactions_count: 0 });
        }

        // Arr√™ter les animations SVG
        function stopSVGAnimations() {
            Object.values(svgAnimationIntervals).forEach(interval => {
                if (interval) clearInterval(interval);
            });
            svgAnimationIntervals = {};
        }

        // Vider les conteneurs SVG
        function clearSVGContainers() {
            ['economy-animation-svg', 'performance-dashboard-svg', 'simplex-steps-svg', 'transaction-detail-svg']
                .forEach(id => {
                    document.getElementById(id).innerHTML =
                        '<div style="color: #666; text-align: center; padding: 50px;">Animation arr√™t√©e</div>';
                });
        }

        // Configuration des conteneurs SVG
        function setupSVGAnimationContainers() {
            // Initialiser les conteneurs avec un message d'attente
            ['economy-animation-svg', 'performance-dashboard-svg', 'simplex-steps-svg', 'transaction-detail-svg']
                .forEach(id => {
                    document.getElementById(id).innerHTML =
                        '<div style="color: #666; text-align: center; padding: 50px;">Cliquez sur D√©marrer</div>';
                });
        }

        // Initialisation au chargement de la page
        document.addEventListener('DOMContentLoaded', function() {
            initializeVisualizations();
            initializeInteractiveSimulation();
        });

        // Nettoyage √† la fermeture de la page
        window.addEventListener('beforeunload', function() {
            if (metricsInterval) {
                clearInterval(metricsInterval);
            }
        });
    </script>
</body>
</html>