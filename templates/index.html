
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ICGS Web Visualizer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
               background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
               min-height: 100vh; color: #333; }
        .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
        .header { text-align: center; color: white; margin-bottom: 30px; }
        .header h1 { font-size: 2.5em; margin-bottom: 10px; }
        .header p { font-size: 1.1em; opacity: 0.9; }
        .dashboard { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 30px; }
        .card { background: white; border-radius: 15px; padding: 25px; box-shadow: 0 10px 30px rgba(0,0,0,0.1); }
        .card h3 { color: #5a67d8; margin-bottom: 20px; font-size: 1.3em; }
        .form-group { margin-bottom: 15px; }
        .form-group label { display: block; margin-bottom: 5px; font-weight: 600; }
        .form-group input, .form-group select { width: 100%; padding: 10px; border: 2px solid #e2e8f0;
                                               border-radius: 8px; font-size: 16px; }
        .btn { background: #5a67d8; color: white; border: none; padding: 12px 24px;
               border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: 600;
               transition: background 0.3s; }
        .btn:hover { background: #4c51bf; }
        .btn-success { background: #38a169; }
        .btn-success:hover { background: #2f855a; }
        .metrics { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; }
        .metric-card { background: #f7fafc; border-left: 4px solid #5a67d8; padding: 15px; border-radius: 8px; }
        .metric-value { font-size: 2em; font-weight: bold; color: #5a67d8; }
        .metric-label { color: #718096; margin-top: 5px; }
        .history { max-height: 400px; overflow-y: auto; }
        .transaction-item { background: #f7fafc; margin: 10px 0; padding: 15px; border-radius: 8px;
                          border-left: 4px solid #38a169; }
        .transaction-item.failed { border-left-color: #e53e3e; }
        .status { display: inline-block; padding: 4px 8px; border-radius: 4px; color: white; font-size: 12px; }
        .status.success { background: #38a169; }
        .status.failed { background: #e53e3e; }
        .loading { text-align: center; padding: 20px; }
        .full-width { grid-column: 1 / -1; }

        /* PHASE 2B: Styles visualisation 3D intégrée */
        .visualization-3d { height: 500px; border: 2px solid #e2e8f0; border-radius: 12px;
                           position: relative; background: #1a202c; overflow: hidden; }
        .viz-controls { display: flex; gap: 10px; align-items: center; margin-bottom: 15px;
                       flex-wrap: wrap; }
        .viz-controls button { padding: 8px 16px; font-size: 14px; }
        .speed-control { display: flex; align-items: center; gap: 8px; }
        .speed-control input { width: 100px; }
        .animation-status { background: #2d3748; color: white; padding: 8px 12px;
                           border-radius: 6px; font-size: 12px; }
        .viz-info { position: absolute; top: 10px; right: 10px; background: rgba(0,0,0,0.7);
                   color: white; padding: 8px 12px; border-radius: 6px; font-size: 12px; }
        .btn-3d { background: #805ad5; }
        .btn-3d:hover { background: #6b46c1; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🚀 ICGS Web Visualizer</h1>
            <p>Interface de Démonstration - Intelligent Computation Graph System</p>
        </div>

        <div class="dashboard">
            <!-- Création d'agents -->
            <div class="card">
                <h3>👥 Création d'Agents Économiques</h3>
                <form id="agentForm">
                    <div class="form-group">
                        <label for="agentId">ID Agent:</label>
                        <input type="text" id="agentId" placeholder="ALICE_FARM" required>
                    </div>
                    <div class="form-group">
                        <label for="sector">Secteur:</label>
                        <select id="sector" required>
                            <option value="">Sélectionner secteur...</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="balance">Balance initiale:</label>
                        <input type="number" id="balance" placeholder="1000" step="0.01" required>
                    </div>
                    <button type="submit" class="btn">Créer Agent</button>
                </form>
            </div>

            <!-- Transaction -->
            <div class="card">
                <h3>💰 Validation de Transaction</h3>
                <form id="transactionForm">
                    <div class="form-group">
                        <label for="sourceId">Agent Source:</label>
                        <input type="text" id="sourceId" placeholder="ALICE_FARM" required>
                    </div>
                    <div class="form-group">
                        <label for="targetId">Agent Cible:</label>
                        <input type="text" id="targetId" placeholder="BOB_INDUSTRY" required>
                    </div>
                    <div class="form-group">
                        <label for="amount">Montant:</label>
                        <input type="number" id="amount" placeholder="100" step="0.01" required>
                    </div>
                    <button type="submit" class="btn">Valider Transaction</button>
                </form>
            </div>

            <!-- Métriques -->
            <div class="card full-width">
                <h3>📊 Métriques de Performance</h3>
                <div id="metricsContainer" class="metrics">
                    <div class="loading">Chargement des métriques...</div>
                </div>
            </div>

            <!-- Historique -->
            <div class="card full-width">
                <h3>📋 Historique des Transactions</h3>
                <button id="runDemo" class="btn btn-success" style="margin-bottom: 15px;">
                    🎯 Lancer Simulation Démo
                </button>
                <div id="historyContainer" class="history">
                    <div class="loading">Aucune transaction encore...</div>
                </div>
            </div>

            <!-- PHASE 2B: Visualisation 3D Intégrée -->
            <div class="card full-width">
                <h3>🌌 Visualisation 3D Algorithme Simplex</h3>

                <div class="viz-controls">
                    <button id="animateLastTx" class="btn btn-3d">🎬 Animer Dernière Transaction</button>
                    <button id="animateDemo" class="btn btn-3d">🎯 Animation Démo</button>
                    <button id="resetAnimation" class="btn">🔄 Reset</button>

                    <div class="speed-control">
                        <label for="speedControl" style="font-size: 14px;">Vitesse:</label>
                        <input type="range" id="speedControl" min="0.1" max="5" value="1" step="0.1">
                        <span id="speedValue">1.0x</span>
                    </div>

                    <div id="animationStatus" class="animation-status">
                        Prêt - Phase 1 Mode Authentique Activé
                    </div>
                </div>

                <div id="visualization3D" class="visualization-3d">
                    <div class="viz-info">
                        <div>Variables f_i authentiques Phase 1</div>
                        <div id="statesInfo">0 états Simplex capturés</div>
                    </div>
                    <div class="loading" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);">
                        🌌 Visualisation 3D sera initialisée après première transaction
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- PHASE 2B: Three.js CDN pour visualisation 3D -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // État global
        let sectors = {};
        let updateInterval;

        // PHASE 2B: Variables globales 3D
        let scene, camera, renderer, animationId;
        let simplexStates = [];
        let animationSpeed = 1.0;
        let isAnimating = false;
        let currentStateIndex = 0;

        // Initialisation
        document.addEventListener('DOMContentLoaded', function() {
            loadSectors();
            updateMetrics();
            updateHistory();
            init3DVisualization();  // PHASE 2B: Initialiser 3D

            // Mise à jour automatique toutes les 5 secondes
            updateInterval = setInterval(() => {
                updateMetrics();
                updateHistory();
                update3DInfo();  // PHASE 2B: Mettre à jour infos 3D
            }, 5000);
        });

        // Charger secteurs disponibles
        async function loadSectors() {
            try {
                const response = await fetch('/api/sectors');
                sectors = await response.json();

                const sectorSelect = document.getElementById('sector');
                sectorSelect.innerHTML = '<option value="">Sélectionner secteur...</option>';

                Object.keys(sectors).forEach(name => {
                    const sector = sectors[name];
                    const option = document.createElement('option');
                    option.value = name;
                    option.textContent = `${name} - ${sector.description}`;
                    sectorSelect.appendChild(option);
                });
            } catch (error) {
                console.error('Erreur chargement secteurs:', error);
            }
        }

        // Mise à jour métriques
        async function updateMetrics() {
            try {
                const response = await fetch('/api/metrics');
                const data = await response.json();

                const container = document.getElementById('metricsContainer');
                const perf = data.performance;

                const successRateFeas = perf.total_transactions > 0 ?
                    (perf.successful_feasibility / perf.total_transactions * 100).toFixed(1) : 0;
                const successRateOpt = perf.total_transactions > 0 ?
                    (perf.successful_optimization / perf.total_transactions * 100).toFixed(1) : 0;

                container.innerHTML = `
                    <div class="metric-card">
                        <div class="metric-value">${perf.agents_count}</div>
                        <div class="metric-label">Agents Créés</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">${perf.total_transactions}</div>
                        <div class="metric-label">Transactions Totales</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">${successRateFeas}%</div>
                        <div class="metric-label">Succès FEASIBILITY</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">${successRateOpt}%</div>
                        <div class="metric-label">Succès OPTIMIZATION</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">${perf.avg_validation_time_ms.toFixed(2)}ms</div>
                        <div class="metric-label">Temps Moyen</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">${perf.sectors_used.length}</div>
                        <div class="metric-label">Secteurs Utilisés</div>
                    </div>
                `;
            } catch (error) {
                console.error('Erreur métriques:', error);
            }
        }

        // Mise à jour historique
        async function updateHistory() {
            try {
                const response = await fetch('/api/history?limit=10');
                const history = await response.json();

                const container = document.getElementById('historyContainer');

                if (history.length === 0) {
                    container.innerHTML = '<div class="loading">Aucune transaction encore...</div>';
                    return;
                }

                container.innerHTML = history.reverse().map(tx => `
                    <div class="transaction-item ${tx.feasibility.success && tx.optimization.success ? '' : 'failed'}">
                        <strong>${tx.tx_id}</strong>: ${tx.source_id} → ${tx.target_id} (${tx.amount})
                        <br>
                        <span class="status ${tx.feasibility.success ? 'success' : 'failed'}">
                            FEASIBILITY: ${tx.feasibility.success ? '✓' : '✗'} (${tx.feasibility.time_ms}ms)
                        </span>
                        <span class="status ${tx.optimization.success ? 'success' : 'failed'}">
                            OPTIMIZATION: ${tx.optimization.success ? '✓' : '✗'} (${tx.optimization.time_ms}ms)
                        </span>
                        <small style="float: right; color: #718096;">
                            ${new Date(tx.timestamp).toLocaleTimeString()}
                        </small>
                    </div>
                `).join('');
            } catch (error) {
                console.error('Erreur historique:', error);
            }
        }

        // Form handlers
        document.getElementById('agentForm').addEventListener('submit', async function(e) {
            e.preventDefault();

            const agentId = document.getElementById('agentId').value;
            const sector = document.getElementById('sector').value;
            const balance = document.getElementById('balance').value;

            try {
                const response = await fetch('/api/agents', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        agent_id: agentId,
                        sector: sector,
                        balance: parseFloat(balance),
                        metadata: {name: agentId, created_via: 'web_interface'}
                    })
                });

                const result = await response.json();
                if (result.success) {
                    alert(`✅ Agent ${agentId} créé avec succès!`);
                    this.reset();
                } else {
                    alert(`❌ Erreur: ${result.error}`);
                }
            } catch (error) {
                alert(`❌ Erreur: ${error.message}`);
            }
        });

        document.getElementById('transactionForm').addEventListener('submit', async function(e) {
            e.preventDefault();

            const sourceId = document.getElementById('sourceId').value;
            const targetId = document.getElementById('targetId').value;
            const amount = document.getElementById('amount').value;

            try {
                const response = await fetch('/api/transaction', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        source_id: sourceId,
                        target_id: targetId,
                        amount: parseFloat(amount)
                    })
                });

                const result = await response.json();
                if (result.success) {
                    const tx = result.transaction;
                    alert(`✅ Transaction validée!
FEASIBILITY: ${tx.feasibility.success ? '✓' : '✗'}
OPTIMIZATION: ${tx.optimization.success ? '✓' : '✗'}`);
                    this.reset();
                } else {
                    alert(`❌ Erreur: ${result.error}`);
                }
            } catch (error) {
                alert(`❌ Erreur: ${error.message}`);
            }
        });

        document.getElementById('runDemo').addEventListener('click', async function() {
            this.disabled = true;
            this.textContent = '⏳ Lancement démo...';

            try {
                const response = await fetch('/api/simulation/run_demo');
                const result = await response.json();

                if (result.success) {
                    alert(`✅ ${result.message}
${result.agents_created} agents créés
${result.transactions_processed} transactions traitées`);
                } else {
                    alert(`❌ Erreur: ${result.error}`);
                }
            } catch (error) {
                alert(`❌ Erreur: ${error.message}`);
            } finally {
                this.disabled = false;
                this.textContent = '🎯 Lancer Simulation Démo';
            }
        });

        // ============================================================================
        // PHASE 2B: Fonctions Visualisation 3D Intégrée
        // ============================================================================

        function init3DVisualization() {
            const container = document.getElementById('visualization3D');

            // Scene Three.js
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a202c);

            // Caméra
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(5, 5, 5);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);

            // Vider container et ajouter canvas
            container.innerHTML = '';
            container.appendChild(renderer.domElement);

            // Ajouter info overlay
            const infoDiv = document.createElement('div');
            infoDiv.className = 'viz-info';
            infoDiv.innerHTML = `
                <div>Variables f_i authentiques Phase 1</div>
                <div id="statesInfo">0 états Simplex capturés</div>
            `;
            container.appendChild(infoDiv);

            // Lumières
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            scene.add(directionalLight);

            // Axes 3D
            const axesHelper = new THREE.AxesHelper(2);
            scene.add(axesHelper);

            // Labels axes
            addAxisLabels();

            // Contrôles basiques
            addBasicControls();

            // Render initial
            renderer.render(scene, camera);

            // Resize handler
            window.addEventListener('resize', onWindowResize);
        }

        function addAxisLabels() {
            // Créer géométrie texte simple pour les axes
            const loader = new THREE.FontLoader();

            // Pour simplifier, on utilise des sphères colorées comme labels
            const sphereGeometry = new THREE.SphereGeometry(0.1, 8, 8);

            // Axe X - SOURCE (Rouge)
            const xMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const xSphere = new THREE.Mesh(sphereGeometry, xMaterial);
            xSphere.position.set(2.2, 0, 0);
            scene.add(xSphere);

            // Axe Y - TARGET (Vert)
            const yMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const ySphere = new THREE.Mesh(sphereGeometry, yMaterial);
            ySphere.position.set(0, 2.2, 0);
            scene.add(ySphere);

            // Axe Z - SECONDARY (Bleu)
            const zMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff });
            const zSphere = new THREE.Mesh(sphereGeometry, zMaterial);
            zSphere.position.set(0, 0, 2.2);
            scene.add(zSphere);
        }

        function addBasicControls() {
            let mouseDown = false;
            let mouseX = 0, mouseY = 0;

            renderer.domElement.addEventListener('mousedown', function(event) {
                mouseDown = true;
                mouseX = event.clientX;
                mouseY = event.clientY;
            });

            renderer.domElement.addEventListener('mouseup', function() {
                mouseDown = false;
            });

            renderer.domElement.addEventListener('mousemove', function(event) {
                if (!mouseDown) return;

                const deltaX = event.clientX - mouseX;
                const deltaY = event.clientY - mouseY;

                // Rotation caméra simple
                const spherical = new THREE.Spherical();
                spherical.setFromVector3(camera.position);
                spherical.theta -= deltaX * 0.01;
                spherical.phi += deltaY * 0.01;
                spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));

                camera.position.setFromSpherical(spherical);
                camera.lookAt(0, 0, 0);

                mouseX = event.clientX;
                mouseY = event.clientY;
                renderer.render(scene, camera);
            });

            // Zoom avec molette
            renderer.domElement.addEventListener('wheel', function(event) {
                event.preventDefault();
                const scale = event.deltaY > 0 ? 1.1 : 0.9;
                camera.position.multiplyScalar(scale);
                renderer.render(scene, camera);
            });
        }

        function onWindowResize() {
            const container = document.getElementById('visualization3D');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.render(scene, camera);
        }

        async function animateLastTransaction() {
            try {
                // Récupérer dernières données métriques avec animation
                const response = await fetch('/api/metrics');
                const data = await response.json();

                const animationData = data.simplex_3d?.last_animation_data;
                if (!animationData || !animationData.simplex_states || animationData.simplex_states.length === 0) {
                    updateAnimationStatus('❌ Aucune donnée animation disponible');
                    return;
                }

                updateAnimationStatus('🎬 Animation en cours...');
                await animateSimplexStates(animationData);
                updateAnimationStatus('✅ Animation terminée');

            } catch (error) {
                console.error('Erreur animation:', error);
                updateAnimationStatus('❌ Erreur animation: ' + error.message);
            }
        }

        async function animateSimplexStates(animationData) {
            const states = animationData.simplex_states || [];
            const transitions = animationData.simplex_transitions || [];

            // Nettoyer scène des objets précédents
            const objectsToRemove = [];
            scene.traverse((object) => {
                if (object.userData.isSimplexPoint || object.userData.isSimplexLine) {
                    objectsToRemove.push(object);
                }
            });
            objectsToRemove.forEach(obj => scene.remove(obj));

            if (states.length === 0) {
                updateAnimationStatus('⚠️ Aucun état Simplex à animer');
                return;
            }

            updateAnimationStatus(`🎬 Animation ${states.length} états Simplex`);

            // Créer points pour chaque état
            for (let i = 0; i < states.length; i++) {
                const state = states[i];
                const coords = state.coordinates;

                if (!coords || coords.length !== 3) continue;

                // Géométrie sphère
                const geometry = new THREE.SphereGeometry(0.1, 16, 16);

                // Couleur basée sur status
                let color = 0x888888; // Gris par défaut
                if (state.is_optimal) color = 0x00ff00; // Vert pour optimal
                else if (state.is_feasible) color = 0xffaa00; // Orange pour feasible

                const material = new THREE.MeshPhongMaterial({ color: color });
                const sphere = new THREE.Mesh(geometry, material);

                sphere.position.set(coords[0], coords[1], coords[2]);
                sphere.userData.isSimplexPoint = true;
                sphere.userData.stateIndex = i;

                scene.add(sphere);

                // Animation apparition progressive
                sphere.scale.set(0, 0, 0);
                animateScale(sphere, { x: 1, y: 1, z: 1 }, 500 / animationSpeed);

                await new Promise(resolve => setTimeout(resolve, 300 / animationSpeed));
                renderer.render(scene, camera);
            }

            // Créer lignes de transition
            for (const transition of transitions) {
                const fromCoords = transition.from_coordinates;
                const toCoords = transition.to_coordinates;

                if (!fromCoords || !toCoords) continue;

                const points = [
                    new THREE.Vector3(fromCoords[0], fromCoords[1], fromCoords[2]),
                    new THREE.Vector3(toCoords[0], toCoords[1], toCoords[2])
                ];

                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({
                    color: 0x666666,
                    linewidth: 2,
                    opacity: 0.7,
                    transparent: true
                });

                const line = new THREE.Line(geometry, material);
                line.userData.isSimplexLine = true;
                scene.add(line);
            }

            renderer.render(scene, camera);
        }

        function animateScale(object, targetScale, duration) {
            const startScale = { x: object.scale.x, y: object.scale.y, z: object.scale.z };
            const startTime = Date.now();

            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);

                object.scale.x = startScale.x + (targetScale.x - startScale.x) * progress;
                object.scale.y = startScale.y + (targetScale.y - startScale.y) * progress;
                object.scale.z = startScale.z + (targetScale.z - startScale.z) * progress;

                if (progress < 1) {
                    requestAnimationFrame(animate);
                }
            }
            animate();
        }

        function updateAnimationStatus(message) {
            document.getElementById('animationStatus').textContent = message;
        }

        function update3DInfo() {
            // Mettre à jour infos nombre d'états capturés
            fetch('/api/metrics')
                .then(response => response.json())
                .then(data => {
                    const simplex3d = data.simplex_3d || {};
                    const statesCount = simplex3d.states_captured || 0;
                    const statesInfo = document.getElementById('statesInfo');
                    if (statesInfo) {
                        statesInfo.textContent = `${statesCount} états Simplex capturés`;
                    }
                })
                .catch(error => console.error('Erreur update 3D info:', error));
        }

        // Event listeners pour contrôles 3D
        document.addEventListener('DOMContentLoaded', function() {
            // Bouton animer dernière transaction
            document.getElementById('animateLastTx')?.addEventListener('click', animateLastTransaction);

            // Bouton animation démo
            document.getElementById('animateDemo')?.addEventListener('click', async function() {
                updateAnimationStatus('🎯 Lancement démo animation...');
                // Lancer d'abord la démo, puis animer
                await document.getElementById('runDemo').click();
                setTimeout(animateLastTransaction, 2000); // Attendre 2s puis animer
            });

            // Bouton reset
            document.getElementById('resetAnimation')?.addEventListener('click', function() {
                if (scene) {
                    // Nettoyer objets Simplex
                    const objectsToRemove = [];
                    scene.traverse((object) => {
                        if (object.userData.isSimplexPoint || object.userData.isSimplexLine) {
                            objectsToRemove.push(object);
                        }
                    });
                    objectsToRemove.forEach(obj => scene.remove(obj));
                    renderer.render(scene, camera);
                }
                updateAnimationStatus('🔄 Visualisation réinitialisée');
            });

            // Contrôle vitesse
            document.getElementById('speedControl')?.addEventListener('input', function(e) {
                animationSpeed = parseFloat(e.target.value);
                document.getElementById('speedValue').textContent = animationSpeed.toFixed(1) + 'x';
            });
        });
    </script>
</body>
</html>
